---
interface Props {
  collapsible?: boolean;
  defaultExpanded?: boolean;
  class?: string;
}

const { collapsible = true, defaultExpanded = true, class: className = '' } = Astro.props;
---

<div
  class={`file-tree ${className}`}
  data-collapsible={collapsible}
  data-default-expanded={defaultExpanded}
>
  <slot />
</div>

<script>
  // SVG icon templates
  const folderIcon =
    '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>';
  const fileIcon =
    '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>';
  const chevronRightIcon =
    '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>';
  const chevronDownIcon =
    '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>';
  const copyIcon =
    '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
  const checkIcon =
    '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';

  interface TreeNode {
    name: string;
    type: 'directory' | 'file';
    path: string;
    level: number;
    children?: TreeNode[];
  }

  function parseTreeText(text: string): TreeNode[] {
    const lines = text
      .trim()
      .split('\n')
      .filter((line: string) => line.trim());
    const root: TreeNode[] = [];
    const stack: Array<{ node: TreeNode; indent: number }> = [];

    lines.forEach((line) => {
      const trimmed = line.trim();
      if (!trimmed) return;

      // Calculate indent level (assuming 2 spaces per level)
      const indent = line.length - line.trimStart().length;
      const isDirectory =
        trimmed.endsWith('/') || (!trimmed.includes('.') && !trimmed.match(/\.\w+$/));
      const name = trimmed.replace(/\/$/, '');

      const node: TreeNode = {
        name,
        type: isDirectory ? ('directory' as const) : ('file' as const),
        path: name,
        level: 0,
        children: isDirectory ? ([] as TreeNode[]) : undefined,
      };

      // Find parent based on indent
      while (stack.length > 0 && stack[stack.length - 1].indent >= indent) {
        stack.pop();
      }

      if (stack.length === 0) {
        root.push(node);
        if (isDirectory) {
          stack.push({ node, indent });
        }
      } else {
        const parent = stack[stack.length - 1].node;
        if (parent.children) {
          node.level = parent.level + 1;
          parent.children.push(node);
          node.path = `${parent.path}/${name}`;
          if (isDirectory) {
            stack.push({ node, indent });
          }
        }
      }
    });

    return root;
  }

  function getFileIcon(_filename: string): string {
    // Return file icon SVG - we'll use the same icon for all files for simplicity
    // Can be enhanced later with file type specific icons
    return fileIcon;
  }

  function createTreeNode(
    node: TreeNode,
    collapsible: boolean,
    defaultExpanded: boolean
  ): HTMLElement {
    const isDir = node.type === 'directory';
    const expandable = isDir && collapsible && (node.children?.length || 0) > 0;
    const expanded = defaultExpanded;

    const nodeDiv = document.createElement('div');
    nodeDiv.className = `tree-node ${isDir ? 'tree-directory' : 'tree-file'} ${expanded ? 'expanded' : ''}`;
    nodeDiv.setAttribute('data-path', node.path);
    nodeDiv.setAttribute('data-level', node.level.toString());
    nodeDiv.setAttribute('role', isDir ? 'treeitem' : 'none');
    if (expandable) {
      nodeDiv.setAttribute('aria-expanded', expanded ? 'true' : 'false');
    }

    // Toggle button or spacer
    if (expandable) {
      const toggle = document.createElement('button');
      toggle.className = 'tree-toggle';
      toggle.setAttribute('aria-label', `Toggle ${node.name}`);
      toggle.setAttribute('data-path', node.path);
      toggle.innerHTML = expanded ? chevronDownIcon : chevronRightIcon;
      nodeDiv.appendChild(toggle);
    } else {
      const spacer = document.createElement('span');
      spacer.className = 'tree-spacer';
      nodeDiv.appendChild(spacer);
    }

    // Icon
    const iconSpan = document.createElement('span');
    iconSpan.className = 'tree-icon';
    iconSpan.innerHTML = isDir ? folderIcon : getFileIcon(node.name);
    iconSpan.setAttribute('aria-hidden', 'true');
    nodeDiv.appendChild(iconSpan);

    // Name
    const nameSpan = document.createElement('span');
    nameSpan.className = 'tree-name';
    nameSpan.textContent = node.name;
    nameSpan.setAttribute('data-path', node.path);
    nodeDiv.appendChild(nameSpan);

    // Copy button
    const copyButton = document.createElement('button');
    copyButton.className = 'tree-copy-path';
    copyButton.setAttribute('data-path', node.path);
    copyButton.setAttribute('aria-label', `Copy path: ${node.path}`);
    copyButton.setAttribute('title', `Copy path: ${node.path}`);
    copyButton.innerHTML = copyIcon;
    nodeDiv.appendChild(copyButton);

    return nodeDiv;
  }

  function renderTree(
    node: TreeNode,
    container: HTMLElement,
    collapsible: boolean,
    defaultExpanded: boolean
  ): void {
    const nodeElement = createTreeNode(node, collapsible, defaultExpanded);
    container.appendChild(nodeElement);

    if (node.type === 'directory' && node.children) {
      const childrenContainer = document.createElement('div');
      childrenContainer.className = `tree-children ${defaultExpanded ? '' : 'hidden'}`;
      childrenContainer.setAttribute('data-parent', node.path);
      childrenContainer.setAttribute('role', 'group');

      node.children.forEach((child: TreeNode) => {
        renderTree(child, childrenContainer, collapsible, defaultExpanded);
      });

      container.appendChild(childrenContainer);
    }
  }

  function initFileTree() {
    const trees = document.querySelectorAll('.file-tree');

    trees.forEach((tree) => {
      const collapsible = tree.getAttribute('data-collapsible') === 'true';
      const defaultExpanded = tree.getAttribute('data-default-expanded') === 'true';

      // Parse text content if it's plain text
      const textContent = tree.textContent?.trim() || '';
      if (textContent && !tree.querySelector('.tree-node')) {
        const nodes = parseTreeText(textContent);
        nodes.forEach((node: TreeNode) => {
          renderTree(node, tree as HTMLElement, collapsible, defaultExpanded);
        });
      }

      // Add toggle functionality
      tree.querySelectorAll('.tree-toggle').forEach((toggle) => {
        toggle.addEventListener('click', (e) => {
          e.stopPropagation();
          const path = toggle.getAttribute('data-path');
          if (!path) return;

          const node = tree.querySelector(`[data-path="${path}"].tree-node`);
          const children = tree.querySelector(`.tree-children[data-parent="${path}"]`);

          if (!node || !children) return;

          const isExpanded = node.classList.contains('expanded');

          if (isExpanded) {
            node.classList.remove('expanded');
            node.setAttribute('aria-expanded', 'false');
            children.classList.add('hidden');
            toggle.innerHTML = chevronRightIcon;
          } else {
            node.classList.add('expanded');
            node.setAttribute('aria-expanded', 'true');
            children.classList.remove('hidden');
            toggle.innerHTML = chevronDownIcon;
          }
        });

        // Keyboard support for toggle
        toggle.addEventListener('keydown', (e: Event) => {
          const keyEvent = e as KeyboardEvent;
          if (keyEvent.key === 'Enter' || keyEvent.key === ' ') {
            keyEvent.preventDefault();
            (toggle as HTMLButtonElement).click();
          }
        });
      });

      // Add copy path functionality
      tree.querySelectorAll('.tree-copy-path').forEach((button) => {
        button.addEventListener('click', async (e) => {
          e.stopPropagation();
          const path = button.getAttribute('data-path');
          if (!path) return;

          try {
            await navigator.clipboard.writeText(path);
            const originalHTML = button.innerHTML;
            button.innerHTML = checkIcon;
            button.classList.add('copied');

            setTimeout(() => {
              button.innerHTML = originalHTML;
              button.classList.remove('copied');
            }, 2000);
          } catch (err) {
            console.error('Failed to copy:', err);
          }
        });

        // Keyboard support for copy
        button.addEventListener('keydown', (e: Event) => {
          const keyEvent = e as KeyboardEvent;
          if (keyEvent.key === 'Enter' || keyEvent.key === ' ') {
            keyEvent.preventDefault();
            (button as HTMLButtonElement).click();
          }
        });
      });

      // Keyboard navigation for tree nodes
      tree.querySelectorAll('.tree-node').forEach((node) => {
        (node as HTMLElement).setAttribute('tabindex', '0');

        node.addEventListener('keydown', (e: Event) => {
          const keyEvent = e as KeyboardEvent;
          const path = (node as HTMLElement).getAttribute('data-path');
          if (!path) return;

          if (keyEvent.key === 'ArrowRight') {
            const toggle = (node as HTMLElement).querySelector(
              '.tree-toggle'
            ) as HTMLButtonElement | null;
            if (toggle && (node as HTMLElement).classList.contains('tree-directory')) {
              if (!(node as HTMLElement).classList.contains('expanded')) {
                toggle.click();
              }
            }
          } else if (keyEvent.key === 'ArrowLeft') {
            const toggle = (node as HTMLElement).querySelector(
              '.tree-toggle'
            ) as HTMLButtonElement | null;
            if (toggle && (node as HTMLElement).classList.contains('tree-directory')) {
              if ((node as HTMLElement).classList.contains('expanded')) {
                toggle.click();
              }
            }
          } else if (keyEvent.key === 'Enter' || keyEvent.key === ' ') {
            const toggle = (node as HTMLElement).querySelector(
              '.tree-toggle'
            ) as HTMLButtonElement | null;
            if (toggle) {
              toggle.click();
            }
          }
        });
      });
    });
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFileTree);
  } else {
    initFileTree();
  }

  // Re-initialize on navigation (Astro View Transitions)
  document.addEventListener('astro:page-load', initFileTree);
</script>

<style>
  .file-tree {
    font-family: 'Inconsolata', monospace;
    font-size: 0.875rem;
    line-height: 1.6;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 0.5rem;
    padding: 1rem;
    margin: 1.5rem 0;
  }

  .tree-node {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.375rem 0.5rem;
    margin: 0.125rem 0;
    cursor: pointer;
    user-select: none;
    border-radius: 0.25rem;
    transition:
      background-color 0.15s ease,
      color 0.15s ease;
    position: relative;
  }

  .tree-node[data-level] {
    padding-left: calc(0.5rem + var(--tree-indent, 0px));
  }

  .tree-node[data-level='1'] {
    --tree-indent: 1.5rem;
  }

  .tree-node[data-level='2'] {
    --tree-indent: 3rem;
  }

  .tree-node[data-level='3'] {
    --tree-indent: 4.5rem;
  }

  .tree-node[data-level='4'] {
    --tree-indent: 6rem;
  }

  .tree-node:hover {
    background: var(--bg-tertiary);
  }

  .tree-node:focus-visible {
    outline: 2px solid var(--accent-blue);
    outline-offset: 2px;
  }

  .tree-toggle {
    width: 1rem;
    height: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    border: none;
    color: var(--fg-muted);
    cursor: pointer;
    padding: 0;
    transition:
      transform 0.2s ease,
      color 0.15s ease;
    flex-shrink: 0;
  }

  .tree-toggle:hover {
    color: var(--fg-secondary);
  }

  .tree-toggle:focus-visible {
    outline: 2px solid var(--accent-blue);
    outline-offset: 2px;
    border-radius: 0.125rem;
  }

  .tree-node.expanded .tree-toggle {
    transform: rotate(0deg);
  }

  .tree-spacer {
    width: 1rem;
    display: inline-block;
    flex-shrink: 0;
  }

  .tree-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    flex-shrink: 0;
    color: var(--fg-muted);
  }

  .tree-icon svg {
    width: 100%;
    height: 100%;
  }

  .tree-directory .tree-icon {
    color: var(--accent-blue);
  }

  .tree-file .tree-icon {
    color: var(--accent-cyan);
  }

  .tree-name {
    color: var(--fg-secondary);
    flex: 1;
    min-width: 0;
  }

  .tree-file .tree-name {
    color: var(--accent-cyan);
  }

  .tree-directory .tree-name {
    color: var(--accent-blue);
    font-weight: 500;
  }

  .tree-copy-path {
    background: transparent;
    border: none;
    color: var(--fg-muted);
    cursor: pointer;
    padding: 0.25rem;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition:
      opacity 0.2s ease,
      color 0.2s ease,
      background-color 0.15s ease;
    border-radius: 0.25rem;
    flex-shrink: 0;
  }

  .tree-copy-path svg {
    width: 14px;
    height: 14px;
  }

  .tree-node:hover .tree-copy-path {
    opacity: 1;
  }

  .tree-copy-path:hover {
    color: var(--accent-green);
    background: var(--bg-tertiary);
  }

  .tree-copy-path:focus-visible {
    outline: 2px solid var(--accent-blue);
    outline-offset: 2px;
    opacity: 1;
  }

  .tree-copy-path.copied {
    color: var(--accent-green);
    opacity: 1;
  }

  .tree-children {
    margin-left: 0;
    border-left: 1px solid var(--border);
    padding-left: 0.75rem;
    margin-top: 0.125rem;
    transition: opacity 0.2s ease;
  }

  .tree-children.hidden {
    display: none;
  }

  /* Improve visual hierarchy with connecting lines */
  .tree-children::before {
    content: '';
    position: absolute;
    left: 0.5rem;
    top: 0;
    bottom: 0;
    width: 1px;
    background: var(--border);
    opacity: 0.5;
  }
</style>
