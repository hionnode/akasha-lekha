---
// Component for displaying Table of Contents minimap
---

<!-- Desktop: Sticky minimap on right -->
<aside
  id="toc-minimap"
  class="hidden xl:block fixed right-8 top-24 w-[280px] max-h-[calc(100vh-8rem)]"
>
  <div class="sticky top-24">
    <div
      class="bg-bg-secondary/50 backdrop-blur-sm border border-border rounded-lg overflow-hidden"
    >
      <!-- Reading progress indicator -->
      <div class="h-1 bg-bg-tertiary">
        <div
          id="toc-progress-bar"
          class="h-full bg-gradient-to-r from-accent-blue to-accent-cyan transition-all duration-150"
          style="width: 0%"
        >
        </div>
      </div>

      <div class="p-4">
        <h2
          class="text-xs font-semibold mb-3 text-fg-muted uppercase tracking-wider flex items-center gap-2"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="14"
            height="14"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M3 9h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9Z"></path>
            <path d="m3 9 2.45-4.9A2 2 0 0 1 7.24 3h9.52a2 2 0 0 1 1.8 1.1L21 9"></path>
            <path d="M12 3v6"></path>
          </svg>
          On this page
        </h2>
        <nav
          id="toc-minimap-nav"
          class="toc-nav-container max-h-[calc(100vh-12rem)] overflow-y-auto minimap-scroll"
        >
          <!-- TOC will be populated by JavaScript -->
        </nav>
      </div>
    </div>
  </div>
</aside>

<style>
  .toc-nav-container {
    display: flex;
    flex-direction: column;
    gap: 0.125rem;
  }

  .minimap-scroll::-webkit-scrollbar {
    width: 4px;
  }

  .minimap-scroll::-webkit-scrollbar-track {
    background: transparent;
  }

  .minimap-scroll::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 2px;
  }

  .minimap-scroll::-webkit-scrollbar-thumb:hover {
    background: var(--accent-blue);
  }
</style>

<script>
  function initTOCMinimap() {
    console.log('[TOC] Initializing TOC Minimap...');

    const tocNav = document.getElementById('toc-minimap-nav');
    const tocContainer = document.getElementById('toc-minimap');
    const article = document.getElementById('article-content');
    const progressBar = document.getElementById('toc-progress-bar');

    console.log('[TOC] Elements found:', { tocNav, article, headingsFound: !!article });

    if (!article || !tocNav) {
      console.warn('[TOC] Missing required elements');
      return;
    }

    // Find all h2, h3, and h4 headings
    const headings = article.querySelectorAll('.prose h2, .prose h3, .prose h4');
    console.log('[TOC] Found headings:', headings.length);

    if (headings.length === 0) {
      // Hide TOC if no headings
      if (tocContainer) tocContainer.style.display = 'none';
      console.log('[TOC] No headings found, hiding TOC');
      return;
    }

    // Clear existing content first
    tocNav.innerHTML = '';

    // Build links using DOM methods instead of innerHTML
    const fragment = document.createDocumentFragment();

    headings.forEach((heading, index) => {
      const id = heading.id || `heading-${index}`;
      const level = heading.tagName.toLowerCase();

      // Get only the direct text content of the heading, not nested elements
      let text = '';
      heading.childNodes.forEach((node) => {
        if (node.nodeType === Node.TEXT_NODE) {
          text += node.textContent;
        }
      });
      text = text.trim();

      // Fallback to textContent if no direct text nodes
      if (!text) {
        text = (heading.textContent || '').trim();
      }

      // Set ID if not present
      if (!heading.id) {
        heading.id = id;
      }

      // Skip empty headings
      if (!text) {
        console.log('[TOC] Skipping empty heading at index', index);
        return;
      }

      // Create link element
      const link = document.createElement('a');
      link.href = `#${id}`;
      link.className = `toc-minimap-link ${level}`;
      link.setAttribute('data-toc-minimap-item', '');
      link.setAttribute('data-heading-id', id);
      link.textContent = text;

      fragment.appendChild(link);

      console.log('[TOC] Added link:', { level, text: text.substring(0, 30) + '...' });
    });

    // Append all links at once
    tocNav.appendChild(fragment);
    console.log('[TOC] TOC populated with', tocNav.children.length, 'links');

    // Setup interaction
    setupMinimapInteraction(headings, progressBar);
  }

  function setupMinimapInteraction(headings: NodeListOf<Element>, progressBar: HTMLElement | null) {
    const tocLinks = document.querySelectorAll('a[data-toc-minimap-item]');
    console.log('[TOC] Setting up interaction for', tocLinks.length, 'links');

    // Smooth scroll on click
    tocLinks.forEach((link) => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetId = (link as HTMLAnchorElement).getAttribute('href')?.substring(1);
        if (targetId) {
          const target = document.getElementById(targetId);
          if (target) {
            const headerOffset = 100;
            const elementPosition = target.getBoundingClientRect().top;
            const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

            window.scrollTo({
              top: offsetPosition,
              behavior: 'smooth',
            });
          }
        }
      });
    });

    // Intersection Observer for active highlighting
    const observerOptions = {
      root: null,
      rootMargin: '-100px 0px -66%',
      threshold: 0,
    };

    const observerCallback: IntersectionObserverCallback = (entries) => {
      entries.forEach((entry) => {
        const id = entry.target.id;
        const tocLink = document.querySelector(`a[data-heading-id="${id}"]`);

        if (entry.isIntersecting) {
          // Remove active from all
          document.querySelectorAll('a[data-toc-minimap-item]').forEach((link) => {
            link.classList.remove('active');
          });

          // Add active to current
          if (tocLink) {
            tocLink.classList.add('active');

            // Scroll into view within minimap
            tocLink.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
          }
        }
      });
    };

    const observer = new IntersectionObserver(observerCallback, observerOptions);
    headings.forEach((heading) => observer.observe(heading));

    // Update progress bar
    function updateProgress() {
      if (!progressBar) return;

      const article = document.getElementById('article-content');
      if (!article) return;

      const articleTop = article.offsetTop;
      const articleHeight = article.offsetHeight;
      const windowHeight = window.innerHeight;
      const scrollTop = window.scrollY || document.documentElement.scrollTop;

      const scrolled = Math.max(0, scrollTop - articleTop + windowHeight);
      const total = articleHeight + windowHeight;
      const progress = Math.min(100, (scrolled / total) * 100);

      progressBar.style.width = `${progress}%`;
    }

    // Throttled scroll handler
    let ticking = false;
    function onScroll() {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          updateProgress();
          ticking = false;
        });
        ticking = true;
      }
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    updateProgress();
  }

  // Initialize with multiple strategies
  console.log('[TOC] Registering initialization handlers...');

  // Strategy 1: DOMContentLoaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      console.log('[TOC] DOMContentLoaded - initializing');
      setTimeout(initTOCMinimap, 100);
    });
  } else {
    // Strategy 2: Already loaded
    console.log('[TOC] Document already loaded - initializing');
    setTimeout(initTOCMinimap, 100);
  }

  // Strategy 3: Astro page load event
  document.addEventListener('astro:page-load', () => {
    console.log('[TOC] Astro page load - initializing');
    setTimeout(initTOCMinimap, 100);
  });
</script>
