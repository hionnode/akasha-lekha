---
import { getCollection } from 'astro:content';

// Get all unique tags from posts
const allPosts = await getCollection('blog', ({ data }) => !data.draft);
const allTags = Array.from(
  new Set(allPosts.flatMap((post) => post.data.tags || []))
).sort();

const tagCounts: Record<string, number> = {};
allPosts.forEach((post) => {
  post.data.tags?.forEach((tag) => {
    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
  });
});
---

<div class="mb-6 p-6 bg-bg-secondary border border-border rounded-lg">
  <!-- Search Bar -->
  <div class="mb-6">
    <label for="blog-search" class="block text-sm font-semibold text-fg-secondary mb-2">
      Search
    </label>
    <input
      type="text"
      id="blog-search"
      placeholder="Search posts by title, excerpt, or tags..."
      class="w-full px-4 py-2 bg-bg-primary border border-border rounded focus:outline-none focus:ring-2 focus:ring-accent-blue focus:border-accent-blue text-fg-primary font-mono text-sm"
    />
  </div>

  <!-- Sort Options -->
  <div class="mb-6">
    <label for="blog-sort" class="block text-sm font-semibold text-fg-secondary mb-2">
      Sort by
    </label>
    <select
      id="blog-sort"
      class="w-full px-4 py-2 bg-bg-primary border border-border rounded focus:outline-none focus:ring-2 focus:ring-accent-blue focus:border-accent-blue text-fg-primary font-mono text-sm"
    >
      <option value="date-desc">Newest First</option>
      <option value="date-asc">Oldest First</option>
      <option value="title-asc">Title (A-Z)</option>
      <option value="title-desc">Title (Z-A)</option>
    </select>
  </div>

  <!-- Tag Filter -->
  <div>
    <label class="block text-sm font-semibold text-fg-secondary mb-3">
      Filter by Tags
    </label>
    <div id="tag-filter-container" class="flex flex-wrap gap-2">
      {allTags.map((tag) => (
        <button
          data-tag={tag}
          class="tag-filter-btn px-3 py-1.5 text-xs font-semibold uppercase tracking-wider border border-border bg-bg-primary text-fg-muted hover:bg-bg-tertiary hover:text-accent-blue hover:border-accent-blue transition-colors rounded"
        >
          {tag}
          <span class="ml-2 text-fg-muted">({tagCounts[tag]})</span>
        </button>
      ))}
    </div>
    <div id="active-tags" class="mt-4 flex flex-wrap gap-2 items-center hidden">
      <span class="text-xs text-fg-muted">Active filters:</span>
      <div id="active-tags-list" class="flex flex-wrap gap-2">
        <!-- Active tags will be populated here -->
      </div>
      <button
        id="clear-filters"
        class="text-xs text-accent-blue hover:text-accent-cyan transition-colors hidden"
      >
        Clear all
      </button>
    </div>
  </div>

  <!-- Results Count -->
  <div id="results-count" class="mt-4 text-sm text-fg-muted">
    Showing all posts
  </div>
</div>

<script>
  const searchInput = document.getElementById('blog-search');
  const sortSelect = document.getElementById('blog-sort');
  const tagButtons = document.querySelectorAll('.tag-filter-btn');
  const activeTagsList = document.getElementById('active-tags-list');
  const clearFiltersBtn = document.getElementById('clear-filters');
  const resultsCount = document.getElementById('results-count');
  const emptyState = document.getElementById('empty-state');
  const clearFiltersEmptyBtn = document.getElementById('clear-filters-empty');

  let activeTags = new Set<string>();
  let searchQuery = '';
  let sortBy = 'date-desc';
  interface PostData {
    element: HTMLElement;
    title: string;
    excerpt: string;
    tags: string[];
    date: string;
    featured: boolean;
  }
  let postsData: PostData[] = [];

  function updateActiveTagsDisplay() {
    if (!activeTagsList || !clearFiltersBtn) return;

    activeTagsList.innerHTML = '';
    
    const hasFilters = activeTags.size > 0 || searchQuery.trim().length > 0;
    
    if (!hasFilters) {
      clearFiltersBtn.classList.add('hidden');
      const activeLabel = document.getElementById('active-tags');
      if (activeLabel) activeLabel.classList.add('hidden');
      return;
    }

    const activeLabel = document.getElementById('active-tags');
    if (activeLabel) activeLabel.classList.remove('hidden');
    clearFiltersBtn.classList.remove('hidden');

    // Show search query as a badge if present
    if (searchQuery.trim().length > 0) {
      const searchEl = document.createElement('button');
      searchEl.className =
        'px-2 py-1 text-xs font-semibold uppercase tracking-wider border border-accent-blue bg-accent-blue/20 text-accent-blue hover:bg-accent-blue/30 transition-colors rounded flex items-center gap-1';
      searchEl.innerHTML = `
        Search: "${searchQuery}"
        <span class="text-accent-blue">×</span>
      `;
      searchEl.addEventListener('click', () => {
        searchQuery = '';
        if (searchInput) (searchInput as HTMLInputElement).value = '';
        updateActiveTagsDisplay();
        filterAndSort();
      });
      activeTagsList.appendChild(searchEl);
    }

    // Show tag filters
    activeTags.forEach((tag) => {
      const tagEl = document.createElement('button');
      tagEl.className =
        'px-2 py-1 text-xs font-semibold uppercase tracking-wider border border-accent-blue bg-accent-blue/20 text-accent-blue hover:bg-accent-blue/30 transition-colors rounded flex items-center gap-1';
      tagEl.innerHTML = `
        ${tag}
        <span class="text-accent-blue">×</span>
      `;
      const tagValue = tag as string;
      tagEl.addEventListener('click', () => {
        activeTags.delete(tagValue);
        updateTagButtons();
        updateActiveTagsDisplay();
        filterAndSort();
      });
      activeTagsList.appendChild(tagEl);
    });
  }


  function updateTagButtons() {
    tagButtons.forEach((btn) => {
      const tag = (btn as HTMLElement).dataset.tag;
      if (tag && activeTags.has(tag)) {
        btn.classList.add('bg-accent-blue/20', 'border-accent-blue', 'text-accent-blue');
        btn.classList.remove('bg-bg-primary', 'text-fg-muted');
      } else {
        btn.classList.remove('bg-accent-blue/20', 'border-accent-blue', 'text-accent-blue');
        btn.classList.add('bg-bg-primary', 'text-fg-muted');
      }
    });
  }

  function filterAndSort() {
    const query = searchQuery.toLowerCase().trim();
    let filtered = postsData.filter((post) => {
      // Search filter
      if (query) {
        const matchesSearch =
          post.title.toLowerCase().includes(query) ||
          post.excerpt.toLowerCase().includes(query) ||
          post.tags.some((tag: string) => tag.toLowerCase().includes(query));
        if (!matchesSearch) return false;
      }

      // Tag filter (AND logic - must have all selected tags)
      if (activeTags.size > 0) {
        const hasAllTags = Array.from(activeTags).every((selectedTag: string) =>
          post.tags.some((postTag: string) => postTag.toLowerCase() === selectedTag.toLowerCase())
        );
        if (!hasAllTags) return false;
      }

      return true;
    });

    // Sort
    filtered.sort((a, b) => {
      switch (sortBy) {
        case 'date-desc':
          return new Date(b.date).getTime() - new Date(a.date).getTime();
        case 'date-asc':
          return new Date(a.date).getTime() - new Date(b.date).getTime();
        case 'title-asc':
          return a.title.localeCompare(b.title);
        case 'title-desc':
          return b.title.localeCompare(a.title);
        default:
          return 0;
      }
    });

    // Get the container
    const container = document.getElementById('post-list-container');
    if (!container) return;

    // Reorder and show/hide posts
    const visibleSet = new Set(filtered.map((p) => p.element));
    
    // First, hide all posts
    postsData.forEach((post) => {
      post.element.style.display = 'none';
    });

    // Then, show and reorder filtered posts
    filtered.forEach((post) => {
      post.element.style.display = '';
      container.appendChild(post.element);
    });

    // Update results count
    if (resultsCount) {
      const total = postsData.length;
      const showing = filtered.length;
      if (showing === total) {
        resultsCount.textContent = `Showing all ${total} posts`;
      } else {
        resultsCount.textContent = `Showing ${showing} of ${total} posts`;
      }
    }

    // Show/hide empty state - only show if there are posts but none match filters
    if (emptyState) {
      const hasPosts = postsData.length > 0;
      const hasFilteredResults = filtered.length > 0;
      const hasActiveFilters = activeTags.size > 0 || searchQuery.trim().length > 0;
      
      // Only show empty state if:
      // 1. We have posts loaded
      // 2. We have active filters
      // 3. No posts match the filters
      if (hasPosts && hasActiveFilters && !hasFilteredResults) {
        emptyState.classList.remove('hidden');
      } else {
        emptyState.classList.add('hidden');
      }
    }
  }

  // Search input with debouncing
  let searchTimeout: ReturnType<typeof setTimeout> | null = null;
  if (searchInput) {
    searchInput.addEventListener('input', (e) => {
      const value = (e.target as HTMLInputElement).value;
      
      // Clear previous timeout
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }
      
      // Set new timeout for debouncing (300ms)
      searchTimeout = setTimeout(() => {
        searchQuery = value;
        updateActiveTagsDisplay();
        filterAndSort();
      }, 300);
    });
  }

  // Sort select
  if (sortSelect) {
    sortSelect.addEventListener('change', (e) => {
      const target = e.target as HTMLSelectElement;
      if (target) {
        sortBy = target.value;
        filterAndSort();
      }
    });
  }

  // Tag buttons
  tagButtons.forEach((btn) => {
    btn.addEventListener('click', () => {
      const tag = (btn as HTMLElement).dataset.tag;
      if (tag) {
        if (activeTags.has(tag)) {
          activeTags.delete(tag);
        } else {
          activeTags.add(tag);
        }
        updateTagButtons();
        updateActiveTagsDisplay();
        filterAndSort();
      }
    });
  });

  // Clear filters
  function clearAllFilters() {
    activeTags.clear();
    searchQuery = '';
    if (searchInput) (searchInput as HTMLInputElement).value = '';
    if (sortSelect) (sortSelect as HTMLSelectElement).value = 'date-desc';
    sortBy = 'date-desc';
    if (searchTimeout) {
      clearTimeout(searchTimeout);
      searchTimeout = null;
    }
    updateTagButtons();
    updateActiveTagsDisplay();
    filterAndSort();
  }

  if (clearFiltersBtn) {
    clearFiltersBtn.addEventListener('click', clearAllFilters);
  }

  if (clearFiltersEmptyBtn) {
    clearFiltersEmptyBtn.addEventListener('click', clearAllFilters);
  }

  // Initialize after a short delay to ensure post cards are rendered
  function initialize() {
    // Get all posts data from the page - select wrapper divs that have data attributes
    const postCards = document.querySelectorAll('#post-list-container > [data-post-card]');
    postsData = [];
    
    postCards.forEach((card) => {
      const element = card as HTMLElement;
      // Only process elements that have the required data attributes
      if (element.dataset.title && element.dataset.tags) {
        postsData.push({
          element,
          title: element.dataset.title || '',
          excerpt: element.dataset.excerpt || '',
          tags: JSON.parse(element.dataset.tags || '[]'),
          date: element.dataset.date || '',
          featured: element.dataset.featured === 'true',
        });
      }
    });
    
    updateTagButtons();
    updateActiveTagsDisplay();
    
    // Run initial filter to set correct state
    filterAndSort();
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initialize, 200);
    });
  } else {
    setTimeout(initialize, 200);
  }

  // Re-initialize on navigation (Astro View Transitions)
  document.addEventListener('astro:page-load', () => {
    setTimeout(initialize, 200);
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Only handle shortcuts when not typing in an input/textarea
    const target = e.target as HTMLElement;
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
      return;
    }

    // `/` key focuses search input
    if (e.key === '/' && searchInput) {
      e.preventDefault();
      searchInput.focus();
    }

    // `Esc` key clears filters
    if (e.key === 'Escape') {
      clearAllFilters();
    }
  });
</script>
