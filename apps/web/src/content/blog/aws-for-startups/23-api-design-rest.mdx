---
title: "API Design: REST That Doesn't Make Your Frontend Team Cry"
description: "Design REST APIs with consistent error handling, cursor-based pagination, and trace IDs. API contracts that work for humans, agents, and your future self."
excerpt: "REST that doesn't make your frontend team cry. Consistent error formats, cursor pagination, trace IDs, and API contracts decided by humans, generated by agents."
date: "2026-04-04"
author: "works-on-my.cloud"
tags: ["aws", "devops", "startup", "api-gateway"]
series: "AWS From Zero to Production"
seriesPart: 23
featured: false
draft: true
---

import Alert from '../../../components/shared/Alert.astro';
import ValidationChecklist from '../../../components/blog/guide/ValidationChecklist.astro';
import ComparisonTable from '../../../components/blog/guide/ComparisonTable.astro';
import ComparisonHeader from '../../../components/blog/guide/ComparisonHeader.astro';
import ComparisonRow from '../../../components/blog/guide/ComparisonRow.astro';

Your agent generates three endpoints. Each returns errors differently: one uses `{error: "message"}`, another `{msg: "error", code: 500}`, the third `{errors: [{detail: "..."}]}`. Your frontend needs three different error handlers. This is what happens when agents design APIs. They are inconsistent across calls because each prompt is independent. The agent does not remember what format it used ten minutes ago.

**Time:** About 35 minutes.

**Outcome:** An API contract with a consistent error response format, cursor-based pagination, trace IDs in every response, and five new rules in AGENT-INSTRUCTIONS.md that enforce consistency across every endpoint an agent generates.

---

## Why This Matters

The ALB from [Part 22](/blog/aws-for-startups/22-alb-load-balancer) is ready. HTTPS termination, health checks, target groups. But the ALB does not care what your API returns. It routes traffic to healthy targets. The quality of what those targets respond with is entirely up to you.

Agents are fast at generating REST endpoints. Ask for a user registration endpoint, you get one in seconds. Ask for a product listing endpoint, you get another. The problem is not speed. The problem is that each endpoint is generated in isolation. The agent has no memory of the decisions it made on the last endpoint.

Without a documented API contract, you get three error formats, two pagination styles, and zero trace IDs. Your frontend developer (future you, or a teammate, or another agent) writes a different error handler for every endpoint. Debugging a production issue takes 20 minutes instead of 2 because no response includes a trace ID you can search for in SigNoz.

This is a Design step, not a Generate step. Humans design API contracts. Agents implement them. The contract goes into AGENT-INSTRUCTIONS.md so every future generation is consistent by construction.

---

## What We're Building

- A standard error response format used by every endpoint
- Cursor-based pagination pattern for all list endpoints
- `request_id` and `trace_id` in every API response
- An HTTP status code usage guide
- A versioning strategy
- Five new rules in AGENT-INSTRUCTIONS.md (API Design section)

---

## Error Response Format

Every API needs exactly one error format. Not one per developer, not one per sprint, not one per agent prompt. One format, used everywhere.

Here is the format this series uses:

```json title="Error Response Format"
{
  "error": "VALIDATION_ERROR",
  "message": "Email address is invalid",
  "request_id": "req_01HYX5K3M7NQWP8ZJ2VCR4DTFS",
  "trace_id": "4bf92f3577b34da6a3ce929d0e0e4736",
  "details": [
    {
      "field": "email",
      "reason": "Must be a valid email address"
    }
  ]
}
```

Four required fields, one optional:

| Field | Type | Required | Purpose |
|-------|------|----------|---------|
| `error` | string | Yes | Machine-readable error code (UPPER_SNAKE_CASE) |
| `message` | string | Yes | Human-readable description |
| `request_id` | string | Yes | Unique ID for this request (for support tickets) |
| `trace_id` | string | Yes | Distributed trace ID (for SigNoz/OpenTelemetry) |
| `details` | array | No | Field-level validation errors |

The `error` field is a constant. Your frontend switches on it: `if (error === 'VALIDATION_ERROR')`. The `message` field is for humans reading logs or looking at error screens. These two fields serve different audiences and must never be combined into one.

### Standard Error Codes

Define your error codes upfront. Do not let agents invent them per endpoint.

```typescript title="src/errors/codes.ts"
export const ErrorCodes = {
  // Client errors
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  CONFLICT: 'CONFLICT',
  RATE_LIMITED: 'RATE_LIMITED',

  // Server errors
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',
  DEPENDENCY_FAILED: 'DEPENDENCY_FAILED',
} as const;
```

Every endpoint uses these codes. If an agent generates an endpoint with `error: "user_not_found"`, that is wrong. The code is `NOT_FOUND`. The `message` field carries the context: "User with ID usr_abc123 not found."

<Alert type="caution" title="Agent Trap">

Agents generate different error shapes for different endpoints because each prompt is independent. Endpoint A returns `{error: "message"}`. Endpoint B returns `{errors: [{detail: "..."}]}`. Endpoint C returns `{message: "error", status: 500}`. The agent is not being careless. It is generating what looks correct in isolation. Each format is valid JSON. None of them match each other.

**What catches it:** The API Design section in AGENT-INSTRUCTIONS.md specifies the exact error format. When the agent has this in its context window, it generates consistently. When it does not, it improvises.

</Alert>

### Error Response Helper

Create a single function that builds error responses. Every endpoint calls it. No endpoint constructs error JSON manually.

```typescript title="src/errors/response.ts"
import { randomUUIDv7 } from 'crypto';
import { trace } from '@opentelemetry/api';

interface ErrorResponseOptions {
  error: string;
  message: string;
  status: number;
  details?: Array<{ field: string; reason: string }>;
}

export function errorResponse(opts: ErrorResponseOptions): Response {
  const span = trace.getActiveSpan();
  const traceId = span?.spanContext().traceId ?? 'no-active-trace';

  return new Response(
    JSON.stringify({
      error: opts.error,
      message: opts.message,
      request_id: `req_${randomUUIDv7()}`,
      trace_id: traceId,
      ...(opts.details && { details: opts.details }),
    }),
    {
      status: opts.status,
      headers: { 'Content-Type': 'application/json' },
    }
  );
}
```

The `request_id` is generated per request. The `trace_id` comes from the active OpenTelemetry span (you set up tracing in [Part 5](/blog/aws-for-startups/05-observability-setup)). Both appear in every error response. Both appear in every success response too.

### Success Response Format

Success responses follow the same pattern for metadata:

```json title="Success Response (single resource)"
{
  "data": {
    "id": "usr_01HYX5K3M7NQWP8ZJ2VCR4DTFS",
    "email": "dev@shipfast.io",
    "name": "Developer",
    "createdAt": "2026-04-04T10:30:00Z"
  },
  "request_id": "req_01HYX5K3M7NQWP8ZJ2VCR4DTFS",
  "trace_id": "4bf92f3577b34da6a3ce929d0e0e4736"
}
```

`data` wraps the resource. `request_id` and `trace_id` are always present. The frontend knows exactly where to find the payload (`response.data`) and exactly where to find debugging metadata (`response.request_id`, `response.trace_id`).

---

## Pagination

List endpoints return collections. Without pagination, your endpoint returns every record in the table. That works for 10 users. It does not work for 10,000.

Two approaches exist: offset-based and cursor-based. Pick cursor-based.

<ComparisonTable>
  <ComparisonHeader columns={["Offset", "Cursor"]} />
  <ComparisonRow feature="Query" Offset="?page=3&limit=20" Cursor="?cursor=abc123&limit=20" />
  <ComparisonRow feature="Consistency" Offset="Items shift between pages if data changes" Cursor="Stable position regardless of inserts/deletes (Best)" />
  <ComparisonRow feature="Performance" Offset="O(n) ‚Äî database skips rows" Cursor="O(1) ‚Äî seeks to position (Best)" />
  <ComparisonRow feature="Deep pages" Offset="page=500 scans 10,000 rows" Cursor="Same speed as page 1 (Best)" />
  <ComparisonRow feature="Simplicity" Offset="Easier to implement (Best)" Cursor="Slightly more code" />
  <ComparisonRow feature="Total count" Offset="Easy (SELECT COUNT)" Cursor="Expensive separate query" />
</ComparisonTable>

Offset pagination breaks in two ways. First, performance degrades linearly with page depth. `OFFSET 10000 LIMIT 20` forces the database to scan 10,000 rows before returning 20. Second, if someone inserts a record between page requests, items shift: you see duplicates or miss records entirely.

Cursor pagination solves both. The cursor is an opaque token (typically a base64-encoded ID or timestamp) that marks your position. The database seeks directly to that position regardless of how deep you are.

### Cursor Pagination Response

```json title="Paginated Response"
{
  "data": [
    { "id": "prod_001", "name": "Widget" },
    { "id": "prod_002", "name": "Gadget" }
  ],
  "pagination": {
    "cursor": "eyJpZCI6InByb2RfMDAyIn0=",
    "has_more": true,
    "limit": 20
  },
  "request_id": "req_01HYX5K3M7NQWP8ZJ2VCR4DTFS",
  "trace_id": "4bf92f3577b34da6a3ce929d0e0e4736"
}
```

The `cursor` field is the token the client sends in the next request: `GET /api/v1/products?cursor=eyJpZCI6InByb2RfMDAyIn0=&limit=20`. The `has_more` boolean tells the client whether another page exists. No total count, no page numbers. The client iterates forward until `has_more` is false.

### Implementation Pattern

```typescript title="src/handlers/products.ts"
import { Buffer } from 'buffer';

interface CursorPayload {
  id: string;
  createdAt: string;
}

function encodeCursor(payload: CursorPayload): string {
  return Buffer.from(JSON.stringify(payload)).toString('base64url');
}

function decodeCursor(cursor: string): CursorPayload {
  return JSON.parse(Buffer.from(cursor, 'base64url').toString());
}

async function listProducts(cursor?: string, limit = 20) {
  const safeLimit = Math.min(limit, 100); // Cap at 100

  let query = db
    .select()
    .from(products)
    .orderBy(products.createdAt, 'desc')
    .limit(safeLimit + 1); // Fetch one extra to check has_more

  if (cursor) {
    const decoded = decodeCursor(cursor);
    query = query.where(
      lt(products.createdAt, decoded.createdAt)
    );
  }

  const results = await query;
  const hasMore = results.length > safeLimit;
  const items = hasMore ? results.slice(0, safeLimit) : results;
  const nextCursor = hasMore
    ? encodeCursor({
        id: items[items.length - 1].id,
        createdAt: items[items.length - 1].createdAt,
      })
    : null;

  return { data: items, pagination: { cursor: nextCursor, has_more: hasMore, limit: safeLimit } };
}
```

The trick is `limit + 1`: fetch one extra row. If you get it, there is more data. If you do not, this is the last page. Slice the extra row off before returning. This avoids a separate `COUNT(*)` query.

:::tip
Always cap `limit` with a server-side maximum (100 is reasonable). Without this cap, a client can request `?limit=1000000` and your database returns everything in one query.
:::

---

## Request and Response IDs

Two IDs appear in every response: `request_id` and `trace_id`. They serve different purposes.

**`request_id`** is generated by your API for every incoming request. It is unique, short, and designed for support conversations. A user says "I got an error, here's the request ID: req_01HYX5." You search your logs for that ID and find the exact request.

**`trace_id`** comes from OpenTelemetry. It ties together the API call, the database query, the cache lookup, and the downstream service call into a single distributed trace in SigNoz. You click the trace ID in SigNoz and see the full request lifecycle across services.

Both IDs go into the response headers as well as the response body:

```typescript title="src/middleware/ids.ts"
import { randomUUIDv7 } from 'crypto';
import { trace } from '@opentelemetry/api';

export function attachIds(req: Request): { requestId: string; traceId: string } {
  const requestId = `req_${randomUUIDv7()}`;
  const span = trace.getActiveSpan();
  const traceId = span?.spanContext().traceId ?? 'no-active-trace';

  return { requestId, traceId };
}

export function addIdHeaders(
  response: Response,
  ids: { requestId: string; traceId: string }
): Response {
  response.headers.set('X-Request-Id', ids.requestId);
  response.headers.set('X-Trace-Id', ids.traceId);
  return response;
}
```

Why both headers and body? Headers are accessible from JavaScript (`response.headers.get('X-Request-Id')`) without parsing the body. The body includes them for logging and error display. Belt and suspenders.

---

## HTTP Status Codes

HTTP status codes are not creative expression. They are a protocol. Use them consistently.

| Status | When to Use | Example |
|--------|-------------|---------|
| 200 | Successful GET, PUT, PATCH | Fetching a user, updating a profile |
| 201 | Successful POST that creates a resource | Creating a new user |
| 204 | Successful DELETE (no body) | Deleting a product |
| 400 | Client sent invalid data | Missing required field, wrong type |
| 401 | No valid authentication | Missing or expired token |
| 403 | Authenticated but not authorized | User trying to access admin endpoint |
| 404 | Resource does not exist | User ID not found |
| 409 | Conflict with current state | Email already registered |
| 422 | Syntactically valid but semantically wrong | Date range where start > end |
| 429 | Rate limited | Too many requests from this client |
| 500 | Server error (your bug) | Unhandled exception |
| 502 | Upstream service failure | Database connection timeout |
| 503 | Service temporarily unavailable | During deployment or maintenance |

Three rules:

1. **Never return 200 for errors.** If the request failed, the status code must be 4xx or 5xx. Agents do this constantly: they return `{status: 200, body: {error: "not found"}}` because it is technically valid HTTP. Your frontend's `response.ok` check thinks everything is fine.

2. **Use 404, not 200 with empty body.** `GET /api/v1/users/nonexistent` returns 404, not 200 with `{data: null}`. The client should not have to inspect the body to know whether the resource exists.

3. **Use 422 for business logic validation.** 400 means the request is malformed (bad JSON, wrong types). 422 means the request is structurally valid but violates business rules (start date after end date, negative quantity).

---

## Versioning Strategy

Your API will change. The question is how to manage those changes without breaking existing clients.

Two schools exist: URL versioning (`/api/v1/users`) and header versioning (`Accept: application/vnd.shipfast.v1+json`). Use URL versioning.

URL versioning is visible, debuggable, and simple. You can see the version in browser dev tools, in curl commands, in logs. Header versioning is technically cleaner but practically harder. Developers forget to set the header. Agents forget to include it. Load balancer access logs show the path but not custom headers.

```typescript title="src/routes/index.ts"
// Version in the URL path
app.route('/api/v1/users', usersV1Router);
app.route('/api/v1/products', productsV1Router);

// When v2 is needed (months from now)
app.route('/api/v2/users', usersV2Router);
```

:::note
You do not need v2 today. You probably will not need it for months. But structuring your routes as `/api/v1/...` from the start means v2 is a new router, not a rewrite. The cost of the `/v1/` prefix is zero. The cost of adding versioning later is a migration.
:::

---

## AGENT-INSTRUCTIONS.md: API Design Section

Add these five rules to your AGENT-INSTRUCTIONS.md. After this addition, AGENT-INSTRUCTIONS.md is 53 lines.

```markdown title="AGENT-INSTRUCTIONS.md (append)"
## API Design
- All error responses use same format: {error, message, request_id, trace_id}
- Cursor-based pagination, never offset-based
- Include request_id and trace_id in all API responses
- OpenAPI spec is source of truth
- Agents generate from spec, not ad hoc
```

These five rules prevent the three most common agent-generated API problems: inconsistent error formats, offset pagination, and missing trace IDs. Every future agent prompt that includes AGENT-INSTRUCTIONS.md in its context window will generate endpoints that follow your contract.

The last two rules ("OpenAPI spec is source of truth" and "Agents generate from spec, not ad hoc") set up [Part 24](/blog/aws-for-startups/24-request-validation-openapi), where you write the OpenAPI spec and enforce spec-first generation.

---

## The Fine Line

<Alert type="warning" title="The Fine Line">

| | |
|---|---|
| ‚ùå **Under** | No API contract. Each endpoint returns errors differently. No pagination (return all records). No trace IDs. Frontend writes three error handlers. Debugging a production issue means grepping logs for 20 minutes hoping to find the right request. |
| ‚úÖ **Right** | Consistent error format (`{error, message, request_id, trace_id}`) across all endpoints. Cursor-based pagination. Request and trace IDs in every response. HTTP status codes used correctly. API Design rules in AGENT-INSTRUCTIONS.md. |
| ‚ùå **Over** | GraphQL federation plus REST plus gRPC, API gateway with rate limiting and usage plans, API versioning strategy across 12 microservices, all before you have 10 users. |
| ü§ñ **Agent Trap** | Agent generates inconsistent error formats across endpoints because each prompt is independent. Endpoint A returns `{error: "message"}`. Endpoint B returns `{msg: "error", code: 500}`. Both are valid JSON. Neither matches your contract. AGENT-INSTRUCTIONS.md rules prevent this by giving the agent the contract in every prompt. |

</Alert>

---

## What's Coming

Next in **Part 24: Request Validation & OpenAPI**, you write the OpenAPI spec that becomes the single source of truth for your API. Agents generate endpoint handlers from the spec, not ad hoc. Validation schemas (Zod, Pydantic, Go struct tags) enforce the spec at runtime. The API contract you designed today gets machine-enforced tomorrow.

---

## Validation Checklist

<ValidationChecklist items={[
  {
    category: "API Design",
    tasks: [
      { text: "Error response format documented and consistent across all endpoints", syncKey: "part-23-error-format" },
      { text: "Cursor-based pagination pattern defined (not offset)", syncKey: "part-23-cursor-pagination" },
      { text: "request_id and trace_id included in all responses", syncKey: "part-23-request-trace-ids" },
      { text: "HTTP status codes usage guide created and followed", syncKey: "part-23-status-codes" }
    ]
  },
  {
    category: "AGENT-INSTRUCTIONS.md",
    tasks: [
      { text: "API Design section added (5 rules)", syncKey: "part-23-agent-instructions" },
      { text: "AGENT-INSTRUCTIONS.md now at 53 lines cumulative", syncKey: "part-23-instructions-count" }
    ]
  }
]} />

---

## Key Takeaways

1. Humans design API contracts, agents implement them. This is a Design step, not a Generate step. The contract exists before the first endpoint is generated.
2. Consistent error format (`{error, message, request_id, trace_id}`) across all endpoints eliminates frontend error-handling chaos and makes debugging a 30-second trace ID lookup instead of a 20-minute log grep.
3. Cursor-based pagination scales linearly; offset-based pagination degrades linearly. Pick cursor from day one. The implementation is slightly more complex. The operational behavior is dramatically better.
4. `trace_id` in every response connects API calls to distributed traces in SigNoz. When a user reports an error, you click the trace ID and see exactly what happened across every service.

---

*Have questions? Found an error? [Open an issue](https://github.com/hionnode/akasha-lekha/issues) or reach out on [LinkedIn](https://linkedin.com/in/chinmay-pandey).*
