---
title: "Frontend Deployment: SvelteKit + SolidStart on AWS"
description: "Deploy SvelteKit and SolidStart frontends to S3 + CloudFront. Alternative framework patterns for the same AWS infrastructure stack."
excerpt: "SvelteKit + SolidStart on AWS. Same infrastructure, different frameworks, because your deployment pipeline shouldn't care which framework you chose."
date: "2026-03-16"
author: "works-on-my.cloud"
tags: ["aws", "devops", "startup", "frontend", "s3", "cloudfront"]
series: "AWS From Zero to Production"
seriesPart: 18
featured: false
draft: true
---

import Alert from '../../../components/shared/Alert.astro';
import ValidationChecklist from '../../../components/blog/guide/ValidationChecklist.astro';
import Command from '../../../components/blog/code/Command.astro';
import TerminalOutput from '../../../components/blog/code/TerminalOutput.astro';
import PanelSwitcher from '../../../components/blog/code/PanelSwitcher.astro';
import Panel from '../../../components/blog/code/Panel.astro';
import ComparisonTable from '../../../components/blog/guide/ComparisonTable.astro';
import ComparisonHeader from '../../../components/blog/guide/ComparisonHeader.astro';
import ComparisonRow from '../../../components/blog/guide/ComparisonRow.astro';

You picked React in [Part 17](/blog/aws-for-startups/17-frontend-react-astro). Your co-founder swears by Svelte. The new hire loves Solid. Here is the thing: your AWS deployment pipeline does not care. Same S3 bucket. Same CloudFront distribution. Same Terraform. Same `deploy-frontend.sh`. The framework is a build step. The infrastructure is the constant.

This is the post that proves it. Two frameworks, zero infrastructure changes.

**Time:** About 30 minutes.

**Outcome:** SvelteKit and SolidStart deployed to the same S3 + CloudFront stack from Parts 13-15, proving that your infrastructure is framework-agnostic and your deploy script works unchanged.

---

## Why This Matters

Framework choices are two-way doors. You can swap React for Svelte or Solid without touching a single Terraform resource. The S3 bucket does not know what generated the files it serves. CloudFront does not inspect your JavaScript to check which virtual DOM implementation you chose. Your `Cache-Control` headers work the same whether the HTML was generated by `vite build`, `svelte-kit build`, or `vinxi build`.

When your deployment pipeline is framework-specific, every framework change becomes an infrastructure change. Framework-specific pipelines bake assumptions into CI/CD: specific build commands, specific output directories, specific environment variable prefixes. Changing frameworks means rewriting the pipeline, which means the framework choice becomes a one-way door.

When your pipeline is framework-agnostic, the framework choice stays reversible. Build produces a directory of static files. Deploy syncs that directory to S3. That is the entire contract.

---

## What We're Building

- SvelteKit static adapter configuration for S3 deployment
- SolidStart static preset configuration for S3 deployment
- Proof that `deploy-frontend.sh` from Part 17 works for both without modification
- Framework comparison data: bundle size, build time, hydration strategy

---

## SvelteKit Static Adapter

SvelteKit uses adapters to target different deployment environments. The `adapter-static` adapter produces a directory of pre-rendered HTML, CSS, and JavaScript. Exactly what S3 expects.

Install the adapter:

```bash terminal
npm install -D @sveltejs/adapter-static
```

Configure it:

```javascript title="svelte.config.js"
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
  preprocess: vitePreprocess(),
  kit: {
    adapter: adapter({
      pages: 'build',
      assets: 'build',
      fallback: '404.html',
      precompress: true,
      strict: true,
    }),
  },
};

export default config;
```

The key settings:

- **`pages` and `assets` set to `build`**: Output everything to a single `build/` directory. S3 sync targets this directory.
- **`fallback: '404.html'`**: SvelteKit generates a 404 page that CloudFront can serve for missing routes. This matches the error page configuration you set in [Part 15](/blog/aws-for-startups/15-cloudfront-cdn).
- **`precompress: true`**: Generates `.gz` and `.br` files alongside the originals. CloudFront can serve these directly if you configure the `Accept-Encoding` header in your cache policy.
- **`strict: true`**: Fails the build if any page cannot be pre-rendered. You want this. A silently skipped page means a 404 in production.

Add a prerender directive to your root layout so all pages get statically generated:

```svelte title="src/routes/+layout.ts"
export const prerender = true;
```

Build the project:

```bash terminal
npm run build
```

<TerminalOutput title="SvelteKit build output">

```
vite v6.2.0 building SSR bundle for production...
‚úì 45 modules transformed.
vite v6.2.0 building for production...
‚úì 62 modules transformed.

.svelte-kit/output/client/_app/immutable/entry/start-BzC1d7h4.js    28.15 kB ‚îÇ gzip:  9.87 kB
.svelte-kit/output/client/_app/immutable/chunks/index-Df0ncW2A.js   12.43 kB ‚îÇ gzip:  4.21 kB

Generated 8 pages
Precompressed 24 files with gzip and brotli

> Using @sveltejs/adapter-static
  Wrote site to "build"
```

</TerminalOutput>

The output is in `build/`. Content-hashed assets live in `_app/immutable/`. The `immutable` directory name is a hint: these files never change. Their filenames contain hashes, just like Vite's output from Part 17.

---

## SolidStart Static Export

SolidStart uses Vinxi under the hood. The `static` preset pre-renders all routes and outputs static files.

Configure the static preset:

```typescript title="app.config.ts"
import { defineConfig } from '@solidjs/start/config';

export default defineConfig({
  server: {
    preset: 'static',
    prerender: {
      routes: ['/'],
      crawlLinks: true,
    },
  },
  vite: {
    build: {
      sourcemap: true,
      rollupOptions: {
        output: {
          entryFileNames: 'assets/[name]-[hash].js',
          chunkFileNames: 'assets/[name]-[hash].js',
          assetFileNames: 'assets/[name]-[hash].[ext]',
        },
      },
    },
  },
});
```

The key settings:

- **`preset: 'static'`**: Tells Vinxi to produce static HTML instead of a server bundle.
- **`crawlLinks: true`**: Starting from the root route (`/`), the build process follows every internal link and pre-renders each page. This means you do not need to manually list every route.
- **Rollup output naming**: Same content-hash pattern as React and Astro. Every framework produces hashed filenames, and the deploy script's caching strategy works identically.

Build the project:

```bash terminal
npm run build
```

<TerminalOutput title="SolidStart build output">

```
vinxi v0.5.3

vinxi starting build...
‚úì Client build completed in 2.1s
‚úì Server prerender completed in 0.8s

  dist/public/index.html                         1.28 kB ‚îÇ gzip: 0.62 kB
  dist/public/assets/entry-client-Kx7nBfQ2.js   18.42 kB ‚îÇ gzip: 6.89 kB
  dist/public/assets/web-D4mNk1qE.js             5.31 kB ‚îÇ gzip: 2.14 kB

Pre-rendered 8 routes to dist/public/
```

</TerminalOutput>

The output is in `dist/public/`. Same structure: HTML files at the root, hashed assets in a subdirectory.

---

## Shared Deployment Pipeline

Here is the proof. The `deploy-frontend.sh` script from [Part 17](/blog/aws-for-startups/17-frontend-react-astro) works for all four frameworks without a single modification. The only thing that changes is the `BUILD_DIR` environment variable.

<PanelSwitcher defaultActive="react">
  <Panel label="React" value="react">

```bash terminal
BUILD_DIR=dist S3_BUCKET=your-app-frontend CLOUDFRONT_ID=E1A2B3C4D5 \
  ./scripts/deploy-frontend.sh
```

  </Panel>
  <Panel label="Astro" value="astro">

```bash terminal
BUILD_DIR=dist S3_BUCKET=your-app-frontend CLOUDFRONT_ID=E1A2B3C4D5 \
  ./scripts/deploy-frontend.sh
```

  </Panel>
  <Panel label="SvelteKit" value="sveltekit">

```bash terminal
BUILD_DIR=build S3_BUCKET=your-app-frontend CLOUDFRONT_ID=E1A2B3C4D5 \
  ./scripts/deploy-frontend.sh
```

  </Panel>
  <Panel label="SolidStart" value="solidstart">

```bash terminal
BUILD_DIR=dist/public S3_BUCKET=your-app-frontend CLOUDFRONT_ID=E1A2B3C4D5 \
  ./scripts/deploy-frontend.sh
```

  </Panel>
</PanelSwitcher>

Four frameworks. One script. One S3 bucket. One CloudFront distribution. Zero infrastructure changes.

The deploy script does not know or care which framework produced the files. It syncs a directory to S3 with the correct cache headers and invalidates CloudFront. That is the contract, and every static site generator on the market fulfills it.

<Alert type="caution" title="Agent Trap">

Agents generate framework-specific deployment scripts. Ask an agent to "deploy my SvelteKit app to S3," and it will produce a script that references `_app/immutable/` paths, uses SvelteKit-specific environment variables, and includes a `svelte-kit sync` pre-build step. Ask for SolidStart, and you get a completely different script. Each script works, but now you have four deploy scripts to maintain, and each one encodes framework assumptions that break when you upgrade.

**What catches it:** Compare the agent's deploy script against your existing `deploy-frontend.sh`. If the only difference is the `BUILD_DIR` path, the agent over-specified. Use the generic script.

</Alert>

---

## Framework Comparison

All four frameworks produce deployable static output. The differences are in developer experience, bundle characteristics, and hydration strategy.

<ComparisonTable>
  <ComparisonHeader columns={["React (Vite)", "Astro", "SvelteKit", "SolidStart"]} />
  <ComparisonRow feature="Bundle size (hello world)" React_Vite="142 kB" Astro="12 kB (Best)" SvelteKit="41 kB" SolidStart="24 kB" />
  <ComparisonRow feature="Build time (8 pages)" React_Vite="1.8s" Astro="1.2s (Fastest)" SvelteKit="2.4s" SolidStart="2.9s" />
  <ComparisonRow feature="Hydration" React_Vite="Full page" Astro="Islands (Best)" SvelteKit="Full page" SolidStart="Full page" />
  <ComparisonRow feature="JS shipped (static)" React_Vite="142 kB" Astro="0 kB (Best)" SvelteKit="41 kB" SolidStart="24 kB" />
  <ComparisonRow feature="Static adapter" React_Vite="Built-in" Astro="Built-in" SvelteKit="@sveltejs/adapter-static" SolidStart="Vinxi static preset" />
  <ComparisonRow feature="Output directory" React_Vite="dist/" Astro="dist/" SvelteKit="build/" SolidStart="dist/public/" />
  <ComparisonRow feature="OTel integration" React_Vite="Standard" Astro="Client script" SvelteKit="Standard" SolidStart="Standard" />
</ComparisonTable>

A few observations:

**Astro ships zero JavaScript by default** for static pages. If your site is content-heavy (blogs, docs, marketing pages), Astro gives you the smallest bundle and the fastest load times. Interactive components use islands architecture: only the interactive parts ship JavaScript.

**SolidStart produces the smallest client runtime** among full-SPA frameworks. Solid's reactive system compiles away the virtual DOM, so the framework overhead is minimal. For applications that need interactivity on every page, SolidStart gives you the best size-to-capability ratio.

**SvelteKit's precompress option** generates brotli and gzip files at build time. If you configure CloudFront to serve compressed content (and you should), SvelteKit saves CPU time by pre-compressing instead of compressing on every request. The other frameworks rely on CloudFront's automatic compression.

**React has the largest bundle** for the same content. This is not a criticism of React. React's strength is its ecosystem, hiring pool, and component library breadth. If your team already knows React, the 100 kB difference in bundle size is not worth rewriting your app for. If you are starting fresh, consider the alternatives.

:::note
These numbers come from minimal "hello world" builds with 8 static pages. Real application sizes vary significantly based on dependencies, code splitting, and tree shaking. Run your own builds and compare. The comparison that matters is your app, not a benchmark.
:::

---

## The Fine Line

<Alert type="warning" title="The Fine Line">

| | |
|---|---|
| ‚ùå **Under** | A different deployment pipeline for each framework. Separate CI jobs, separate S3 buckets, separate CloudFront distributions. Every framework change is an infrastructure project. |
| ‚úÖ **Right** | Framework-agnostic pipeline. One deploy script, one S3 bucket, one CloudFront distribution. The framework is a build step that outputs a directory. The pipeline syncs that directory. |
| ‚ùå **Over** | A universal build adapter that normalizes every framework's output into a canonical format, with plugin architecture, config schema validation, and framework auto-detection. You are solving a problem that `BUILD_DIR=build` already solves. |
| ü§ñ **Agent Trap** | Agent generates a SvelteKit-specific deploy script that hardcodes `_app/immutable/` as the assets path for cache headers. When you switch to SolidStart, the cache headers apply to the wrong directory, and your assets get 5-minute caching instead of 1-year caching. Users re-download unchanged JavaScript on every visit. |

</Alert>

---

## What's Coming

Next in **Part 19: Preview Environments, Your First Real Pipeline**, the manual verification you have been doing since Part 13 gets automated. A scripted Generate, Verify, Explain pipeline with an iterative fix loop. Your first custom MCP server. And Recalibration Checkpoint 1, where you measure whether your agents are getting better or worse. Part 19 is a KEY part. Budget 2 hours.

---

## Validation Checklist

<ValidationChecklist items={[
  {
    category: "Deployment",
    tasks: [
      { text: "SvelteKit or SolidStart built with static adapter/preset", syncKey: "part-18-static-build" },
      { text: "Build output deployed to S3 using deploy-frontend.sh", syncKey: "part-18-s3-deploy" },
      { text: "CloudFront serving the application correctly", syncKey: "part-18-cloudfront" },
      { text: "Same deploy script works for both frameworks (only BUILD_DIR changes)", syncKey: "part-18-same-script" }
    ]
  },
  {
    category: "Comparison",
    tasks: [
      { text: "Build output size recorded for your chosen framework", syncKey: "part-18-build-size" },
      { text: "Build time recorded for your chosen framework", syncKey: "part-18-build-time" }
    ]
  }
]} />

---

## Key Takeaways

1. Your deployment pipeline should be framework-agnostic: the framework is a build step that produces a directory, and the infrastructure does not care which tool generated the HTML, CSS, and JavaScript inside it.
2. SvelteKit and SolidStart produce static output that deploys identically to React and Astro. The `deploy-frontend.sh` from Part 17 works unchanged for all four, with only the `BUILD_DIR` variable differing.

---

*Have questions? Found an error? [Open an issue](https://github.com/hionnode/akasha-lekha/issues) or reach out on [LinkedIn](https://linkedin.com/in/chinmay-pandey).*
