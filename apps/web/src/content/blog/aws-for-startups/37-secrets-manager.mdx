---
title: "Secrets Manager: Credentials That Rotate Themselves"
description: "AWS Secrets Manager for database credentials with automatic rotation. Terraform-managed secrets, Lambda rotation functions, and application integration."
excerpt: "Credentials that rotate themselves. Secrets Manager with automatic rotation, because remembering to change passwords quarterly does not scale."
date: "2026-05-28"
author: "works-on-my.cloud"
tags: ["aws", "devops", "startup", "secrets-manager", "security", "terraform"]
series: "aws-for-startups"
seriesPart: 37
draft: true
---

import Alert from '../../../components/shared/Alert.astro';
import ValidationChecklist from '../../../components/blog/guide/ValidationChecklist.astro';
import FileTree from '../../../components/blog/code/FileTree.astro';
import TerminalOutput from '../../../components/blog/code/TerminalOutput.astro';
import ComparisonTable from '../../../components/blog/guide/ComparisonTable.astro';
import ComparisonHeader from '../../../components/blog/guide/ComparisonHeader.astro';
import ComparisonRow from '../../../components/blog/guide/ComparisonRow.astro';

Your database password has been the same since you created the RDS instance in [Part 35](/blog/aws-for-startups/35-rds-postgres). It lives in terraform.tfvars, which is gitignored but still sits as plaintext on every developer's laptop who has ever cloned the repo. If anyone leaves the team, you need to change the password manually, update every service that connects, restart every application instance, and hope you did not miss one. You will not do this. Nobody does. The password stays unchanged for 18 months, sitting in plaintext on laptops that may or may not have disk encryption.

**Time:** About 40 minutes.

**Outcome:** Database credentials stored in AWS Secrets Manager, a Lambda rotation function that changes the password every 30 days automatically, and application code that retrieves credentials at runtime instead of reading them from environment variables or config files.

---

## Why This Matters

In [Part 12](/blog/aws-for-startups/12-env-vars-secrets-security), you established the principle: secrets belong in a secrets manager, not in code, not in .env files, not in terraform.tfvars. That part covered the philosophy. This part implements it for the most critical secret in your infrastructure: the database password.

Manual credential rotation has a 100% failure rate over time. Security best practices say rotate every 90 days. In practice, "rotate every 90 days" means someone creates a calendar reminder, snoozes it twice, and then changes the password on a Friday afternoon, breaking the application because they forgot one service still uses the old credentials. Then they set the password back to the old one. Now they are non-compliant and the calendar reminder resets.

Secrets Manager solves this by making rotation automatic. A Lambda function changes the password, tests the new credential, and updates the stored secret. Your application reads the current password from Secrets Manager at startup (or on a cache interval). No human intervention. No calendar reminders. No Friday afternoon outages.

The cost is $0.40 per secret per month plus $0.05 per 10,000 API calls. For a single database secret retrieved once per application instance at startup, that is under $1/month. Cheaper than one hour of incident response time.

---

## What We're Building

- A Secrets Manager secret containing the RDS database credentials
- A Lambda rotation function using the AWS-provided rotation template for RDS PostgreSQL
- Terraform modules for the secret, rotation configuration, and IAM roles
- Application-side code for retrieving and caching the secret
- Updated RDS configuration that references Secrets Manager instead of terraform.tfvars

---

## Secrets Manager vs Alternatives

Before building, understand why Secrets Manager over the alternatives:

<ComparisonTable>
  <ComparisonHeader columns={["Secrets Manager", "SSM Parameter Store", "HashiCorp Vault"]} />
  <ComparisonRow feature="Auto Rotation" Secrets_Manager="Built-in (Best)" SSM_Parameter_Store="Manual (use Lambda)" HashiCorp_Vault="Built-in" />
  <ComparisonRow feature="RDS Integration" Secrets_Manager="Native Lambda template (Best)" SSM_Parameter_Store="Custom code required" HashiCorp_Vault="Plugin required" />
  <ComparisonRow feature="Cost" Secrets_Manager="$0.40/secret/month" SSM_Parameter_Store="Free (standard) (Best)" HashiCorp_Vault="Self-hosted or $1.58/hr" />
  <ComparisonRow feature="Complexity" Secrets_Manager="Low" SSM_Parameter_Store="Low" HashiCorp_Vault="High (cluster management)" />
  <ComparisonRow feature="Best For" Secrets_Manager="DB credentials, API keys" SSM_Parameter_Store="Config values, non-rotating secrets" HashiCorp_Vault="Multi-cloud, complex rotation" />
</ComparisonTable>

For database credentials with rotation: Secrets Manager. For configuration values that do not need rotation (feature flags, service URLs): SSM Parameter Store SecureString. For a multi-cloud enterprise: Vault. You are a startup with one AWS account. Secrets Manager is the right tool.

---

## Module Structure

<FileTree>
infra/
  modules/
    secrets/
      main.tf
      variables.tf
      outputs.tf
      rotation.tf
      iam.tf
</FileTree>

---

## Creating the Secret

```hcl title="infra/modules/secrets/main.tf"
resource "aws_secretsmanager_secret" "rds_credentials" {
  name        = "${var.project}/${var.environment}/rds/credentials"
  description = "RDS PostgreSQL credentials for ${var.project} ${var.environment}"

  tags = {
    Name        = "${var.project}-${var.environment}-rds-credentials"
    Environment = var.environment
    Project     = var.project
    ManagedBy   = "terraform"
  }
}

resource "aws_secretsmanager_secret_version" "rds_credentials" {
  secret_id = aws_secretsmanager_secret.rds_credentials.id
  secret_string = jsonencode({
    engine   = "postgres"
    host     = var.rds_endpoint
    port     = var.rds_port
    username = var.db_username
    password = var.db_password
    dbname   = var.db_name
  })

  lifecycle {
    ignore_changes = [secret_string]
  }
}
```

Key decisions:

**Secret naming convention:** `{project}/{environment}/rds/credentials`. The forward-slash hierarchy makes it easy to scope IAM policies. An application role can have access to `shipfast/prod/*` without seeing `shipfast/dev/*` secrets.

**lifecycle.ignore_changes:** After the initial creation, the rotation Lambda manages the secret value. If Terraform tries to reset it on every apply, you break rotation. The `ignore_changes` block tells Terraform to manage the secret resource but not overwrite the current value.

**JSON structure:** The secret contains all connection parameters, not just the password. This matches the format that the AWS-provided rotation Lambda expects. It also means your application retrieves one secret and has everything it needs to build a connection string.

<Alert type="caution" title="Agent Trap">

Agents store the database password directly in Terraform state by using `random_password` or hardcoding the value in the `aws_db_instance` resource. Terraform state files are stored in S3 (from [Part 4](/blog/aws-for-startups/04-terraform-fundamentals)), and while the S3 bucket has encryption at rest, the state file contains the password in plaintext JSON. Anyone with access to the state bucket can read every secret Terraform manages.

The fix: create the initial password outside Terraform (or use `random_password` only for the initial setup), immediately store it in Secrets Manager, and enable rotation. After the first rotation, the password in Terraform state is outdated and useless. Add to AGENT-INSTRUCTIONS.md: "Never reference database passwords directly in Terraform resources. Always use Secrets Manager ARN."

</Alert>

---

## IAM for Rotation

The rotation Lambda needs permission to access Secrets Manager and modify the RDS password:

```hcl title="infra/modules/secrets/iam.tf"
data "aws_iam_policy_document" "rotation_assume" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["lambda.amazonaws.com"]
    }
  }
}

resource "aws_iam_role" "rotation" {
  name               = "${var.project}-${var.environment}-secret-rotation"
  assume_role_policy = data.aws_iam_policy_document.rotation_assume.json

  tags = {
    Environment = var.environment
    Project     = var.project
    ManagedBy   = "terraform"
  }
}

data "aws_iam_policy_document" "rotation_policy" {
  statement {
    sid = "SecretsManagerAccess"
    actions = [
      "secretsmanager:GetSecretValue",
      "secretsmanager:DescribeSecret",
      "secretsmanager:PutSecretValue",
      "secretsmanager:UpdateSecretVersionStage",
    ]
    resources = [aws_secretsmanager_secret.rds_credentials.arn]
  }

  statement {
    sid       = "GetRandomPassword"
    actions   = ["secretsmanager:GetRandomPassword"]
    resources = ["*"]
  }

  statement {
    sid = "RDSConnection"
    actions = [
      "rds-db:connect",
    ]
    resources = ["arn:aws:rds-db:${var.region}:${var.account_id}:dbuser:${var.rds_resource_id}/${var.db_username}"]
  }
}

resource "aws_iam_role_policy" "rotation" {
  name   = "secret-rotation-policy"
  role   = aws_iam_role.rotation.id
  policy = data.aws_iam_policy_document.rotation_policy.json
}

resource "aws_iam_role_policy_attachment" "rotation_lambda_basic" {
  role       = aws_iam_role.rotation.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

resource "aws_iam_role_policy_attachment" "rotation_vpc" {
  role       = aws_iam_role.rotation.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
}
```

Notice the scoping: Secrets Manager actions are limited to the specific secret ARN. The `GetRandomPassword` action requires `resources = ["*"]` because it is a service-level action, not a resource-level one. This is one of the rare cases where a wildcard resource is correct.

---

## Rotation Lambda

AWS provides a managed rotation Lambda for RDS credentials. You do not need to write custom rotation code.

```hcl title="infra/modules/secrets/rotation.tf"
resource "aws_security_group" "rotation_lambda" {
  name_prefix = "${var.project}-${var.environment}-rotation-"
  vpc_id      = var.vpc_id
  description = "Security group for Secrets Manager rotation Lambda"

  tags = {
    Name        = "${var.project}-${var.environment}-rotation-lambda"
    Environment = var.environment
    Project     = var.project
    ManagedBy   = "terraform"
  }
}

resource "aws_security_group_rule" "rotation_to_rds" {
  type                     = "egress"
  from_port                = 5432
  to_port                  = 5432
  protocol                 = "tcp"
  source_security_group_id = var.rds_security_group_id
  security_group_id        = aws_security_group.rotation_lambda.id
  description              = "Allow rotation Lambda to connect to RDS"
}

resource "aws_security_group_rule" "rotation_to_secrets" {
  type              = "egress"
  from_port         = 443
  to_port           = 443
  protocol          = "tcp"
  cidr_blocks       = ["0.0.0.0/0"]
  security_group_id = aws_security_group.rotation_lambda.id
  description       = "Allow rotation Lambda to call Secrets Manager API"
}

resource "aws_security_group_rule" "rds_from_rotation" {
  type                     = "ingress"
  from_port                = 5432
  to_port                  = 5432
  protocol                 = "tcp"
  source_security_group_id = aws_security_group.rotation_lambda.id
  security_group_id        = var.rds_security_group_id
  description              = "PostgreSQL from rotation Lambda"
}

resource "aws_secretsmanager_secret_rotation" "rds_credentials" {
  secret_id           = aws_secretsmanager_secret.rds_credentials.id
  rotation_lambda_arn = aws_lambda_function.rotation.arn

  rotation_rules {
    automatically_after_days = 30
  }
}

resource "aws_lambda_function" "rotation" {
  function_name = "${var.project}-${var.environment}-rds-rotation"
  description   = "Rotates RDS credentials in Secrets Manager"

  runtime = "python3.12"
  handler = "lambda_function.lambda_handler"
  timeout = 30

  filename         = data.archive_file.rotation_code.output_path
  source_code_hash = data.archive_file.rotation_code.output_base64sha256

  role = aws_iam_role.rotation.arn

  vpc_config {
    subnet_ids         = var.private_subnet_ids
    security_group_ids = [aws_security_group.rotation_lambda.id]
  }

  environment {
    variables = {
      SECRETS_MANAGER_ENDPOINT = "https://secretsmanager.${var.region}.amazonaws.com"
    }
  }

  tags = {
    Environment = var.environment
    Project     = var.project
    ManagedBy   = "terraform"
  }
}

resource "aws_lambda_permission" "secrets_manager" {
  statement_id  = "AllowSecretsManager"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.rotation.function_name
  principal     = "secretsmanager.amazonaws.com"
}
```

The rotation Lambda runs inside your VPC (same private subnets as RDS) so it can connect to the database. It also needs HTTPS outbound to call the Secrets Manager API. If you have a VPC endpoint for Secrets Manager, use that instead of the 0.0.0.0/0 egress rule.

:::tip
Consider creating a VPC endpoint for Secrets Manager (`com.amazonaws.{region}.secretsmanager`). It keeps rotation traffic within the AWS network, removes the need for NAT Gateway egress, and slightly reduces rotation latency. Cost: $7.20/month per endpoint. Worth it in production.
:::

### How Rotation Works

The rotation Lambda follows a four-step process:

:::steps
1. **createSecret**: Generates a new random password and stores it as a pending version in Secrets Manager
2. **setSecret**: Connects to RDS and changes the database user's password to the new value
3. **testSecret**: Connects to RDS using the new password to verify it works
4. **finishSecret**: Marks the new version as current in Secrets Manager
:::

If any step fails, the Lambda retries. If the test step fails (new password does not work), the old password remains active. The rotation is atomic from the application's perspective: the secret in Secrets Manager always contains a working password.

### Using the AWS-Provided Rotation Template

Instead of writing the rotation Lambda from scratch, use the AWS Serverless Application Repository template:

```bash terminal
aws serverlessrepo create-cloud-formation-change-set \
  --application-id arn:aws:serverlessrepo:us-east-1:297356227824:applications/SecretsManagerRDSPostgreSQLRotationSingleUser \
  --stack-name shipfast-rds-rotation \
  --capabilities CAPABILITY_IAM CAPABILITY_RESOURCE_POLICY
```

Alternatively, download the rotation code from the [AWS Secrets Manager rotation templates repository](https://github.com/aws-samples/aws-secrets-manager-rotation-lambdas) and package it yourself. The Terraform configuration above uses a local archive, which gives you more control over the deployment.

```hcl title="infra/modules/secrets/rotation.tf"
data "archive_file" "rotation_code" {
  type        = "zip"
  source_dir  = "${path.module}/lambda/rotation"
  output_path = "${path.module}/lambda/rotation.zip"
}
```

---

## Application Integration

Your application retrieves the database credentials from Secrets Manager at startup. Do not call Secrets Manager on every database query. Retrieve once, cache in memory, and refresh on a schedule or when the connection fails.

```typescript title="src/lib/db-credentials.ts"
import {
  SecretsManagerClient,
  GetSecretValueCommand,
} from '@aws-sdk/client-secrets-manager';

interface DBCredentials {
  engine: string;
  host: string;
  port: number;
  username: string;
  password: string;
  dbname: string;
}

const client = new SecretsManagerClient({ region: process.env.AWS_REGION });
const SECRET_ARN = process.env.DB_SECRET_ARN;

let cachedCredentials: DBCredentials | null = null;
let cacheExpiry = 0;
const CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes

export async function getDBCredentials(): Promise<DBCredentials> {
  if (cachedCredentials && Date.now() < cacheExpiry) {
    return cachedCredentials;
  }

  const command = new GetSecretValueCommand({ SecretId: SECRET_ARN });
  const response = await client.send(command);

  if (!response.SecretString) {
    throw new Error('Secret value is empty');
  }

  cachedCredentials = JSON.parse(response.SecretString) as DBCredentials;
  cacheExpiry = Date.now() + CACHE_TTL_MS;

  return cachedCredentials;
}

export function buildConnectionString(creds: DBCredentials): string {
  return `postgresql://${creds.username}:${encodeURIComponent(creds.password)}@${creds.host}:${creds.port}/${creds.dbname}?sslmode=require`;
}

export function invalidateCache(): void {
  cachedCredentials = null;
  cacheExpiry = 0;
}
```

```typescript title="src/lib/db.ts"
import { getDBCredentials, buildConnectionString, invalidateCache } from './db-credentials';

export async function getConnection() {
  const creds = await getDBCredentials();
  const connectionString = buildConnectionString(creds);

  try {
    // Use your preferred PostgreSQL client (pg, drizzle, prisma, etc.)
    return await connectToDatabase(connectionString);
  } catch (error) {
    // If connection fails, credentials may have rotated
    // Invalidate cache and retry once
    invalidateCache();
    const freshCreds = await getDBCredentials();
    const freshConnectionString = buildConnectionString(freshCreds);
    return await connectToDatabase(freshConnectionString);
  }
}
```

The retry-on-failure pattern is critical. When rotation occurs, there is a brief window where your cached credentials are the old password and the database expects the new password. The first connection attempt fails, the cache invalidates, the second attempt fetches the new credentials, and the connection succeeds. This window is typically under 2 seconds.

### IAM Policy for Application

Your application's IAM role needs permission to read the secret:

```hcl title="infra/modules/app/iam.tf"
data "aws_iam_policy_document" "app_secrets" {
  statement {
    sid     = "ReadDBCredentials"
    actions = ["secretsmanager:GetSecretValue"]
    resources = [
      "arn:aws:secretsmanager:${var.region}:${var.account_id}:secret:${var.project}/${var.environment}/rds/*"
    ]
  }
}
```

The resource ARN uses a wildcard at the end to cover the random suffix that Secrets Manager appends to secret names. Scope the policy to your project and environment path. Do not use `Resource: "*"` for Secrets Manager.

---

## Updating RDS to Use Secrets Manager

Update the RDS module from [Part 35](/blog/aws-for-startups/35-rds-postgres) to reference the Secrets Manager secret instead of a variable for the password:

```hcl title="infra/modules/rds/main.tf"
resource "aws_db_instance" "main" {
  identifier = "${var.project}-${var.environment}-postgres"

  # ... (all other settings remain the same)

  username                    = var.db_username
  manage_master_user_password = true

  # Remove the 'password' argument entirely.
  # manage_master_user_password tells RDS to create and manage
  # the password in Secrets Manager automatically.
}
```

RDS has a native Secrets Manager integration via `manage_master_user_password`. When set to `true`, RDS creates a Secrets Manager secret for the master password automatically and handles rotation. This is the simplest path if you are setting up a new instance.

For existing instances (like the one from Part 35), the migration requires:

:::steps
1. Store the current password in Secrets Manager (done above)
2. Configure the rotation Lambda
3. Trigger the first rotation manually
4. Update your application to read from Secrets Manager
5. Remove the password from terraform.tfvars
:::

Trigger the first rotation manually to verify the entire chain works:

```bash terminal
aws secretsmanager rotate-secret \
  --secret-id shipfast/prod/rds/credentials
```

<TerminalOutput title="aws secretsmanager rotate-secret">

```json
{
    "ARN": "arn:aws:secretsmanager:us-east-1:123456789012:secret:shipfast/prod/rds/credentials-AbCdEf",
    "Name": "shipfast/prod/rds/credentials",
    "VersionId": "a1b2c3d4-5678-90ab-cdef-EXAMPLE11111"
}
```

</TerminalOutput>

Check rotation status:

```bash terminal
aws secretsmanager describe-secret \
  --secret-id shipfast/prod/rds/credentials \
  --query '{LastRotated:LastRotatedDate,NextRotation:NextRotationDate,Status:RotationEnabled}' \
  --output table
```

After the rotation completes (30-60 seconds), connect to the database using the new credentials:

```bash terminal
# Retrieve the new password
aws secretsmanager get-secret-value \
  --secret-id shipfast/prod/rds/credentials \
  --query 'SecretString' \
  --output text | python3 -c "import sys,json; print(json.load(sys.stdin)['password'])"
```

If this password works against the database, rotation is operational. The next rotation happens automatically in 30 days.

---

## Connection to Part 12

In [Part 12](/blog/aws-for-startups/12-env-vars-secrets-security), you established three tiers of configuration:

1. **Public config:** Non-sensitive values in version control (region, instance type, feature flags)
2. **Environment-specific config:** Per-environment values in terraform.tfvars or SSM Parameter Store
3. **Secrets:** Sensitive values in Secrets Manager with rotation

The database password just moved from tier 2 (terraform.tfvars, gitignored but plaintext) to tier 3 (Secrets Manager, encrypted, automatically rotated). Every credential in your infrastructure should eventually live in tier 3.

Candidates for Secrets Manager in future parts:
- API keys for third-party services (Stripe, SendGrid, Clerk)
- Redis AUTH tokens (covered in [Part 38](/blog/aws-for-startups/38-elasticache-redis))
- JWT signing keys
- Encryption keys for application-level encryption

---

## The Fine Line

<Alert type="warning" title="The Fine Line">

| | |
|---|---|
| ‚ùå **Under** | Database password hardcoded in terraform.tfvars (or worse, in application code). Never rotated. The password from initial setup is still active 18 months later on every developer's laptop. |
| ‚úÖ **Right** | Secrets Manager with automatic 30-day rotation for RDS credentials. Application retrieves credentials at startup with in-memory cache and retry-on-failure. Rotation Lambda in VPC with scoped IAM permissions. |
| ‚ùå **Over** | HashiCorp Vault cluster with dynamic database credentials, Vault Agent sidecar on every container, and a dedicated Vault ops team for a single PostgreSQL instance. $500+/month in infrastructure plus ongoing operational overhead. |
| ü§ñ **Agent Trap** | Agent stores the database password directly in the `aws_db_instance` resource's `password` field, which means the password appears in plaintext in Terraform state. The agent does this because it is the shortest path to a working `terraform apply`. Checkov flags unencrypted secrets in state. The fix: use `manage_master_user_password = true` or reference a Secrets Manager ARN. |

</Alert>

---

## What's Coming

Next in **Part 38: ElastiCache Redis**, we add a caching layer between your application and the database. Redis handles session storage, frequently-read data, and rate limiting. The connection pattern mirrors what you built here: credentials in Secrets Manager, application retrieves them at runtime, retry on rotation.

---

## Validation Checklist

<ValidationChecklist items={[
  {
    category: "Secrets Manager",
    tasks: [
      { text: "Secret created in Secrets Manager with correct naming convention", syncKey: "part-37-secret-created" },
      { text: "Secret contains JSON with engine, host, port, username, password, dbname", syncKey: "part-37-secret-format" },
      { text: "Secret lifecycle ignores changes in Terraform (rotation manages the value)", syncKey: "part-37-lifecycle" }
    ]
  },
  {
    category: "Rotation",
    tasks: [
      { text: "Rotation Lambda deployed in VPC private subnets", syncKey: "part-37-lambda-deployed" },
      { text: "Rotation Lambda security group allows egress to RDS (5432) and Secrets Manager (443)", syncKey: "part-37-lambda-sg" },
      { text: "RDS security group allows ingress from rotation Lambda", syncKey: "part-37-rds-sg-updated" },
      { text: "First manual rotation completed successfully", syncKey: "part-37-first-rotation" },
      { text: "Application connects with new credentials after rotation", syncKey: "part-37-app-connect" }
    ]
  },
  {
    category: "Application",
    tasks: [
      { text: "Application reads credentials from Secrets Manager (not environment variables)", syncKey: "part-37-app-reads-sm" },
      { text: "Credentials cached in memory with TTL", syncKey: "part-37-caching" },
      { text: "Retry-on-failure pattern implemented for rotation window", syncKey: "part-37-retry" }
    ]
  },
  {
    category: "Security",
    tasks: [
      { text: "Application IAM role scoped to specific secret ARN (not wildcard)", syncKey: "part-37-iam-scoped" },
      { text: "Database password removed from terraform.tfvars", syncKey: "part-37-no-tfvars" },
      { text: "Rotation IAM role follows least privilege", syncKey: "part-37-rotation-iam" }
    ]
  }
]} />

---

## Key Takeaways

1. Secrets Manager with automatic rotation means credentials change without human intervention, and $0.40/month per secret is cheaper than one hour of incident response when a leaked password is exploited.
2. Never store secrets in Terraform state. Use `manage_master_user_password = true` for new instances or reference Secrets Manager by ARN for existing ones.
3. Cache retrieved secrets in application memory with a TTL, and implement retry-on-failure for the brief window during credential rotation.
4. The secret naming convention `{project}/{environment}/service/type` maps directly to IAM resource policies, making it easy to scope access per environment.
5. Every hardcoded credential is a liability with an expiration date you cannot predict. Secrets Manager replaces "remember to rotate" with "rotation happens."

---

*Have questions? Found an error? [Open an issue](https://github.com/hionnode/akasha-lekha/issues) or reach out on [LinkedIn](https://linkedin.com/in/chinmay-pandey).*
