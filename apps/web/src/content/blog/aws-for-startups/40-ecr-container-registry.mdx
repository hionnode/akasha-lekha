---
title: "ECR: Your Private Container Registry"
date: "2026-06-08"
excerpt: "Your private container registry. ECR with lifecycle policies and vulnerability scanning, because Docker Hub rate limits aren't a deployment strategy."
description: "Set up Amazon ECR for private container storage. Lifecycle policies, vulnerability scanning, and Terraform-managed registry configuration."
series: "aws-for-startups"
seriesPart: 40
draft: true
tags: ["aws", "devops", "startup", "ecr", "docker", "terraform"]
author: "Chinmay"
---

import Alert from '../../../components/shared/Alert.astro';
import ValidationChecklist from '../../../components/blog/guide/ValidationChecklist.astro';
import FileTree from '../../../components/blog/code/FileTree.astro';

Your CI pipeline pulls `python:3.12-slim` from Docker Hub. It has done this 150 times today across your team's branches. On pull 151, Docker Hub returns a 429: rate limit exceeded. Your deployment fails. Not because your code is broken. Not because AWS is down. Because Docker Hub gives anonymous users 100 pulls per 6 hours and authenticated free users 200. You just exceeded your quota pulling a base image.

**Time:** About 30 minutes.

**Outcome:** Private ECR repositories for your Bun, Python, and Go services with lifecycle policies that prevent unbounded image accumulation, vulnerability scanning enabled, and Terraform managing the entire setup.

---

## Why This Matters

Docker Hub is a public registry. Your production images should not live on a public registry, and your builds should not depend on a public registry's rate limits.

Three problems with Docker Hub for production:

1. **Rate limits.** 100 pulls per 6 hours for anonymous, 200 for free accounts. In a CI pipeline that builds on every push, you hit this limit on a busy day. Your deployment fails for a reason that has nothing to do with your code.

2. **Public exposure risk.** If you accidentally push to a public Docker Hub repository instead of a private one, your application code and dependencies are visible to everyone. ECR repositories are private by default.

3. **Latency.** Docker Hub is not in your AWS region. ECR is. Pulling a 250 MB image from Docker Hub over the internet takes 15-30 seconds. Pulling from ECR within the same region takes 3-5 seconds. In a deployment pipeline, that difference adds up.

ECR solves all three. Private by default, no rate limits within AWS, same-region latency, and it integrates natively with ECS (which you'll deploy to in [Part 41](/blog/aws-for-startups/41-ecs-fargate-bun)).

---

## What We're Building

- Three ECR repositories (bun-api, python-api, go-api) via Terraform
- Lifecycle policies to automatically clean up old images
- Vulnerability scanning enabled on image push
- Push and pull workflow from your local machine and CI

---

## ECR Repositories with Terraform

Each service gets its own ECR repository. One repository per service, not one repository for everything.

```hcl title="infra/modules/ecr/main.tf"
resource "aws_ecr_repository" "service" {
  for_each = var.repositories

  name                 = "${var.project}-${var.environment}-${each.key}"
  image_tag_mutability = "IMMUTABLE"
  force_delete         = false

  image_scanning_configuration {
    scan_on_push = true
  }

  encryption_configuration {
    encryption_type = "AES256"
  }

  tags = merge(var.common_tags, {
    Name    = "${var.project}-${var.environment}-${each.key}"
    Service = each.key
  })
}
```

```hcl title="infra/modules/ecr/variables.tf"
variable "project" {
  description = "Project name"
  type        = string
}

variable "environment" {
  description = "Environment name"
  type        = string
}

variable "repositories" {
  description = "Map of repository names to configuration"
  type        = map(object({
    max_image_count = optional(number, 10)
  }))
}

variable "common_tags" {
  description = "Common tags for all resources"
  type        = map(string)
}
```

```hcl title="infra/modules/ecr/outputs.tf"
output "repository_urls" {
  description = "Map of repository name to URL"
  value       = { for k, v in aws_ecr_repository.service : k => v.repository_url }
}

output "repository_arns" {
  description = "Map of repository name to ARN"
  value       = { for k, v in aws_ecr_repository.service : k => v.arn }
}
```

Key decisions:

- **`image_tag_mutability = "IMMUTABLE"`** prevents overwriting a tag. Once `v1.2.3` is pushed, it cannot be replaced. This guarantees that a given tag always refers to the same image. Mutable tags are how `:latest` causes unpredictable deployments.
- **`scan_on_push = true`** scans every image for vulnerabilities as soon as it is pushed. Free for basic scanning.
- **`force_delete = false`** prevents accidental deletion of repositories that contain images. You must explicitly empty a repository before deleting it.

### Calling the Module

```hcl title="infra/environments/dev/ecr.tf"
module "ecr" {
  source = "../../modules/ecr"

  project     = var.project
  environment = var.environment
  common_tags = local.common_tags

  repositories = {
    "bun-api"    = { max_image_count = 10 }
    "python-api" = { max_image_count = 10 }
    "go-api"     = { max_image_count = 10 }
  }
}
```

Apply it:

```bash terminal
cd infra/environments/dev
terraform plan -out=tfplan
terraform apply tfplan
```

---

## Lifecycle Policies

Without a lifecycle policy, every image you push stays in ECR forever. After six months of CI builds, you have 500 images per repository. At $0.10 per GB per month, a 250 MB Python image stored 500 times costs $12.50/month. Not catastrophic, but completely unnecessary. You only need the last 10 images.

```hcl title="infra/modules/ecr/main.tf (add after aws_ecr_repository)"
resource "aws_ecr_lifecycle_policy" "cleanup" {
  for_each   = aws_ecr_repository.service
  repository = each.value.name

  policy = jsonencode({
    rules = [
      {
        rulePriority = 1
        description  = "Remove untagged images after 1 day"
        selection = {
          tagStatus   = "untagged"
          countType   = "sinceImagePushed"
          countUnit   = "days"
          countNumber = 1
        }
        action = {
          type = "expire"
        }
      },
      {
        rulePriority = 2
        description  = "Keep only last N tagged images"
        selection = {
          tagStatus     = "tagged"
          tagPrefixList = ["v"]
          countType     = "imageCountMoreThan"
          countNumber   = var.repositories[each.key].max_image_count
        }
        action = {
          type = "expire"
        }
      }
    ]
  })
}
```

Two rules:

1. **Untagged images expire after 1 day.** Failed builds, intermediate layers, and orphaned images get cleaned up automatically.
2. **Keep only the last N tagged images.** For dev environments, 10 is enough. For production, you might keep 20-30 for rollback capability.

<Alert type="caution" title="Agent Trap">

Agents create ECR repositories without lifecycle policies every time. The repository works, images push and pull successfully, and the agent considers the task complete. Six months later, you have 500+ images per repository and a growing storage bill.

**What catches it:** Your Terraform review checklist from [Part 7](/blog/aws-for-startups/07-branch-protection-pr) should include "lifecycle policy present on all ECR repositories." If `aws_ecr_repository` exists without a corresponding `aws_ecr_lifecycle_policy`, the review fails.

</Alert>

---

## Vulnerability Scanning

ECR offers two scanning modes:

| Feature | Basic Scanning | Enhanced Scanning |
|---------|---------------|-------------------|
| Cost | Free | $0.09 per image scan |
| Database | Clair (open source) | Amazon Inspector (NVD + more) |
| Frequency | On push | On push + continuous |
| Languages | OS packages only | OS packages + application dependencies |

For a startup, basic scanning is sufficient. It catches known CVEs in OS packages at no cost. Enable enhanced scanning when you need application-level dependency scanning or continuous monitoring, which matters more after you have paying customers.

Basic scanning is already enabled by `scan_on_push = true` in our Terraform module. Check scan results after pushing:

```bash terminal
aws ecr describe-image-scan-findings \
  --repository-name shipfast-dev-bun-api \
  --image-id imageTag=v1.0.0 \
  --query 'imageScanFindings.findingSeverityCounts'
```

You should see output like:

```json title="Scan results"
{
    "CRITICAL": 0,
    "HIGH": 0,
    "MEDIUM": 2,
    "LOW": 5,
    "INFORMATIONAL": 12
}
```

Zero CRITICAL and HIGH means you are clear to deploy. MEDIUM and LOW findings should be tracked and addressed in your next base image update.

---

## Push and Pull Workflow

### Authenticate Docker with ECR

ECR uses temporary authentication tokens. You authenticate Docker with ECR before pushing or pulling:

```bash terminal
aws ecr get-login-password --region us-east-1 | \
  docker login --username AWS --password-stdin \
  123456789012.dkr.ecr.us-east-1.amazonaws.com
```

The token is valid for 12 hours. In CI, you run this at the start of every build job.

### Build and Push

```bash terminal
# Build the image
docker build -t bun-api:v1.0.0 -f services/bun-api/Dockerfile services/bun-api/

# Tag for ECR
docker tag bun-api:v1.0.0 \
  123456789012.dkr.ecr.us-east-1.amazonaws.com/shipfast-dev-bun-api:v1.0.0

# Push to ECR
docker push \
  123456789012.dkr.ecr.us-east-1.amazonaws.com/shipfast-dev-bun-api:v1.0.0
```

### Pull

```bash terminal
docker pull \
  123456789012.dkr.ecr.us-east-1.amazonaws.com/shipfast-dev-bun-api:v1.0.0
```

### Scripting the Workflow

Wrap the build-tag-push sequence in a script so you don't type the full ECR URL every time:

```bash title="scripts/ecr-push.sh"
#!/usr/bin/env bash
set -euo pipefail

SERVICE=$1
TAG=$2
ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
REGION=$(aws configure get region)
ECR_URL="${ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com"
REPO_NAME="shipfast-dev-${SERVICE}"

echo "Building ${SERVICE}:${TAG}..."
docker build -t "${SERVICE}:${TAG}" -f "services/${SERVICE}/Dockerfile" "services/${SERVICE}/"

echo "Tagging for ECR..."
docker tag "${SERVICE}:${TAG}" "${ECR_URL}/${REPO_NAME}:${TAG}"

echo "Pushing to ECR..."
docker push "${ECR_URL}/${REPO_NAME}:${TAG}"

echo "Done. Image: ${ECR_URL}/${REPO_NAME}:${TAG}"
```

Usage:

```bash terminal
./scripts/ecr-push.sh bun-api v1.0.0
./scripts/ecr-push.sh python-api v1.0.0
./scripts/ecr-push.sh go-api v1.0.0
```

---

## Terraform File Structure

<FileTree>
infra/
  modules/
    ecr/
      main.tf
      variables.tf
      outputs.tf
  environments/
    dev/
      ecr.tf
      terraform.tfvars
</FileTree>

---

## The Fine Line

<Alert type="warning" title="The Fine Line">

| | |
|---|---|
| ‚ùå **Under** | Using Docker Hub for production images. Rate limits break your deployment pipeline on a busy day. Public repository risk exposes your application code. |
| ‚úÖ **Right** | ECR with lifecycle policies (keep last 10 tagged, expire untagged after 1 day), vulnerability scanning on push, Terraform-managed, immutable tags. |
| ‚ùå **Over** | Multi-region ECR replication, cross-account pull-through cache, for a single-region application with one deployment target. Adds complexity for a scaling problem you don't have yet. |
| ü§ñ **Agent Trap** | Agent creates ECR repository without lifecycle policy. Images accumulate indefinitely, storage costs grow linearly, and you don't notice until a quarterly cost review six months later. |

</Alert>

---

## What's Coming

Next in **Part 41: ECS Fargate, Bun.js API Without Managing Servers**, we take the Docker images in ECR and deploy them to ECS Fargate. Task definitions, service configuration, ALB integration, auto-scaling, and structured logging. Your containers go from "built and stored" to "running in production."

---

## Validation Checklist

<ValidationChecklist items={[
  {
    category: "Infrastructure",
    tasks: [
      { text: "ECR repositories created for all three services via Terraform", syncKey: "part-40-ecr-repos" },
      { text: "Image tag mutability set to IMMUTABLE", syncKey: "part-40-immutable-tags" },
      { text: "Lifecycle policies attached to all repositories", syncKey: "part-40-lifecycle" },
      { text: "Vulnerability scanning enabled (scan_on_push = true)", syncKey: "part-40-scanning" }
    ]
  },
  {
    category: "Workflow",
    tasks: [
      { text: "Docker authenticated to ECR successfully", syncKey: "part-40-ecr-login" },
      { text: "At least one image pushed to ECR", syncKey: "part-40-image-pushed" },
      { text: "Scan results checked with zero CRITICAL findings", syncKey: "part-40-scan-results" },
      { text: "ecr-push.sh script created and tested", syncKey: "part-40-push-script" }
    ]
  }
]} />

---

## Key Takeaways

1. ECR eliminates Docker Hub rate limits and keeps your images private by default, solving two deployment risks with one service.
2. Lifecycle policies prevent image accumulation: agents never create them, so check every `aws_ecr_repository` for a corresponding `aws_ecr_lifecycle_policy`.
3. Immutable tags guarantee that `v1.2.3` always means the same image, which is the foundation of reproducible deployments.

---

*Have questions? Found an error? [Open an issue](https://github.com/hionnode/akasha-lekha/issues) or reach out on [LinkedIn](https://linkedin.com/in/chinmay-pandey).*
